---
layout: post
title: GPLGPU Walkthrough
date: '2016-07-24T06:56:00.000-07:00'
author: Jeff
tags:
- hardware
- 3d rendering
- gpu
modified_time: '2016-11-04T07:02:21.846-07:00'
thumbnail: https://2.bp.blogspot.com/-9nl4AyyR6JA/V5S4aw4dZkI/AAAAAAAACVk/KUj5m5W2WgA9evgFbMI6eVDOs6PyDcsJACLcB/s72-c/bdgram2.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-2914133411022413739
blogger_orig_url: http://latchup.blogspot.com/2016/07/gplgpu-walkthrough.html
---

A few years ago, an interesting kickstarter projected popped up:<br /><br />https://www.kickstarter.com/projects/725991125/open-source-graphics-processor-gpu<br /><br />The goal was to publish source code to a GPU that is register compatible with the late 90's era <a href="https://en.wikipedia.org/wiki/Number_Nine_Visual_Technology" target="_blank">Number Nine</a>&nbsp;"Ticket To Ride IV" GPU. Although the project didn't meet its funding goal, the person behind it later published the code on github.<br /><br /><a href="https://github.com/asicguy/gplgpu">https://github.com/asicguy/gplgpu</a><br /><br />Although this is an older design, it has a lots that is worth studying. It's instructive to compare it to the VideoCore GPU that I walked through in a <a href="{{ site.baseurl }}{% post_url 2016-02-26-life-of-triangle %}" target="_blank">previous post</a>. While there are some fundamental differences, there are surprising number of similarities, which shows how modern GPUs evolved from earlier ones.<br /><br /><a name='more'></a><br />Here are some differences between the two:<br /><div class="p1"></div><ul><li>Unlike VideoCore, GPLGPU is a pure fixed function GPU. It does not support shaders or programmable operations.</li><li>GPLGPU does not support vertex transforms. The CPU performs all vertex transformations and lighting, then sends information about the triangles to the GPU. VideoCore implements almost the entire rendering pipeline in hardware, including vertex transforms.</li><li>VideoCore is a graphics core. It's only interface to the outside world is a memory interface that it can write to and read from. It is ignorant of video output devices. GPLGPU is a graphics card. It has a tightly integrated VGA controller and dedicated on-board graphics memory.</li><li>VideoCore uses tiled mode rendering. It completely draws each rectangular part of the screen to on-chip SRAM before copying it to external memory and moving to the next one. This reduces memory bandwidth, which is important if you are sharing memory with a CPU and other functional units. GPLGPU is an immediate mode renderer. It copies pixels to its dedicated graphics SDRAM memory immediately after it computes them.&nbsp;</li></ul><div>The project includes a <a href="https://github.com/asicguy/gplgpu/blob/master/docs/GPLGPU.docx?raw=true" target="_blank">technical reference manual</a> that documents the programmers interface to the video card. I've simplified the block diagram from page 1-2:</div><div><div class="separator" style="clear: both; text-align: center;"><a href="{{ site.url }}/assets/2016-07-24-image-0000.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2016-07-24-image-0000.png" /></a></div></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="p1">Here's a quick overview of these components:<br /><br /><ul><li><b>Host Bus Interface</b>&nbsp;Implements <a href="https://en.wikipedia.org/wiki/Conventional_PCI" target="_blank">PCI</a> bus protocol Allows the host CPU to write directly to display RAM or to registers that control internal card functions.</li><li><b>Linear Windows Controller </b>Performs color conversion and address translation/decoding for host transactions that read and write display RAM</li><li><b>Display List Processor</b>&nbsp;Reads lists of commands from display RAM and executes them to offload the CPU</li><li><b>Drawing Engine</b>&nbsp;Performs accelerated drawing operations, including 2D operations like lines and blits, and 3D triangle fills.</li><li><b>VGA Controller</b>&nbsp;Drive&nbsp;<a href="https://en.wikipedia.org/wiki/Video_Graphics_Array" target="_blank">VGA</a> timing and color signals, reading framebuffer data from display RAM.</li><li><b>Memory Controller</b>&nbsp;Drives control signals for internal display memory and arbitrates between functional blocks that access memory.</li><li><b>Display RAM </b>This stores a few things:</li><ul><li>Frame buffer: The VGA controller continually DMAs video data out of this to the screen and the rendering engine copies data into it.</li><li>Source textures: The CPU must copy these into display RAM for the GPU to use it</li><li>Display list: list of command parameters, discussed below.</li></ul></ul>This is a&nbsp;big&nbsp;project with over 5 million lines of code. But it's organized fairly logically into subdirectories by function. The Verilog code is in the hdl/ directory. Here is an overview of the directories, which I've grouped together by area:<br /><br /></div><table border="1"><tbody><tr><td rowspan="5">Drawing Engine</td><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/de" target="_blank">de/</a></td><td>2D drawing engine and command processor</td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/de3d" target="_blank">de3d/</a></td><td>3D drawing engine </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/dlp" target="_blank">dlp/</a></td><td>Display list processor </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/lucy_tc" target="_blank">lucy_tc/</a></td><td>Texture cache </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/math" target="_blank">math/</a></td><td>Floating point math modules used by other blocks.</td></tr><tr><td rowspan="8">Glue</td><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/include" target="_blank">include/</a></td><td>Global defines </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/sim_lib" target="_blank">sim_lib/</a></td><td>Simulator stubs (block memory, etc)</td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/top" target="_blank">top/</a></td><td>Top level module for FPGA </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/graph_core" target="_blank">graph_core/</a></td><td>Top level module for ASIC </td></tr><tr><td>pll_intf/</td><td>Phase locked loop clock generators </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/hbi" target="_blank">hbi/</a></td><td>Host bus interface </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/generic" target="_blank">generic/</a></td><td>A generic FIFO that is used in other modules </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/ram_based" target="_blank">ram_based/</a></td><td>Utility modules like async FIFOs. </td></tr><tr><td rowspan="2">Memory Controller</td><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/mc_graph" target="_blank">mc_graph/</a></td><td>Memory controller for on-board graphics RAM.</td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/mc_cache" target="_blank">mc_cache/</a></td><td>Some utility modules supporting the memory controller</td></tr><tr><td rowspan="6">VGA Controller</td><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/clk_gen" target="_blank">clk_gen/</a></td><td>Generates various clocks used by VGA </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/clk_switch" target="_blank">clk_switch/</a></td><td>Generates CRT clock from pixel clock </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/crt_sp" target="_blank">crt_sp/</a></td><td>VGA display control registers</td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/vga" target="_blank">vga/</a></td><td>VGA output logic</td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/bios_internal" target="_blank">bios_internal/</a></td><td>VGA BIOS ROM </td></tr><tr><td><a href="https://github.com/asicguy/gplgpu/tree/master/hdl/ramdac_sp" target="_blank">ramdac_sp/</a></td><td>Various display functions, palette, cursor control </td></tr><tr><td rowspan="8">FPGA Blocks</td><td>altera_clk_synth/</td><td></td></tr><tr><td>altera_ddr3/</td><td></td></tr><tr><td>altera_ddr3_128/</td><td></td></tr><tr><td>altera_ddr3_128_sim/</td><td></td></tr><tr><td>altera_fifos/</td><td></td></tr><tr><td>altera_plls/</td><td></td></tr><tr><td>altera_project/</td><td></td></tr><tr><td>altera_rams/</td><td></td></tr></tbody></table><br /><i>There is also an extra directory called de_temp that contains copies of many modules that are in de. It looks like it was perhaps a working directory or merge cruft. I sent an email to Frank Bruno, the author to ask about it. It had been a few years, so he didn't remember the exact details, but also though it was probably just a working directory. I've ignored it here.</i><br /><br /><div>For now, I'm going to ignore the video card components and focus on the drawing engine. Also, I will focus on the 3D rendering operations and ignore 2D-only acceleration functions on GPLGPU like bit blits and lines. This functionality is in the <b>de</b>, <b>de3d</b>, <b>lucy_tc</b>, <b>math</b>, and <b>mc_graph</b> directories, a more manageable ~30k lines of code.<br /><br />As I did with the VideoCore, I tried to trace the path of a triangle from the host interface to the screen and attached my notes here. Usual caveats apply: I've probably gotten details wrong or misunderstood some things. Corrections and clarifications are welcome.<br /><br /></div><h2>Software Interface</h2>After the CPU has performed vertex transformations and lighting, it initiates rendering by writing parameters for a triangle to control registers that are mapped into host memory. Section 2.3.6 of the documentation defines the memory map. Here are some of the registers:<br /><br /><table border="1"><tbody><tr><th>Register Address</th><th>Register Name</th><th>Description </th></tr><tr><td>0x0050</td><td>CMD_OPC</td><td>CMD Opcode Field </td></tr><tr><td>...</td><td>...</td><td>... </td></tr><tr><td>0x0178</td><td>CP0</td><td>Command Parameter 0 </td></tr><tr><td>0x017c</td><td>CP1</td><td>Command Parameter 1 </td></tr><tr><td>0x0180</td><td>CP2</td><td>Command Parameter 2 </td></tr><tr><td>0x0184</td><td>CP3</td><td>Command Parameter 3 </td></tr><tr><td>0x0188</td><td>CP4</td><td>Command Parameter 4 </td></tr><tr><td>...</td><td>...</td><td>... </td></tr><tr><td>0x01D8</td><td>CP4</td><td>Command Parameter 24 </td></tr><tr><td>0x01DC</td><td>3D_TRIG</td><td>Trigger Register for 3D </td></tr></tbody></table><br />The meaning of the command parameter registers depends on the command opcode field. To draw a triangle, we will use the opcode TRIAN_3D (0x09), defined in section 5.8.15. Section 6.7&nbsp;defines the parameters for the TRIAN_3D command:<br /><br /><table border="1"><tbody><tr><th>Register</th><th>Parameter</th><th>Format</th><th>Description </th></tr><tr><td>CP0</td><td>PPTR</td><td>X-Y</td><td>Pattern Pointer </td></tr><tr><td>CP1</td><td>V0_X</td><td>Float</td><td>Vertex 0 X </td></tr><tr><td>CP2</td><td>V0_Y</td><td>Float</td><td>Vertex 0 Y </td></tr><tr><td>CP3</td><td>V0_Z</td><td>Float</td><td>Vertex 0 Z </td></tr><tr><td>CP4</td><td>V0_W</td><td>Float</td><td>Vertex 0 W </td></tr><tr><td>CP5</td><td>V0_C</td><td>Int</td><td>Vertex 0 Color {A, R, G, B} </td></tr><tr><td>CP6</td><td>V0_S</td><td>Int</td><td>Vertex 0 Specular </td></tr><tr><td>CP7</td><td>V0_U</td><td>Float</td><td>Vertex 0 U </td></tr><tr><td>CP8</td><td>V0_V</td><td>Float</td><td>Vertex 0 V </td></tr><tr><td>CP9</td><td>V1_X</td><td>Float</td><td>Vertex 1 X </td></tr><tr><td>CP10</td><td>V1_Y</td><td>Float</td><td>Vertex 1 Y </td></tr><tr><td>CP11</td><td>V1_Z</td><td>Float</td><td>Vertex 1 Z </td></tr><tr><td>CP12</td><td>V1_W</td><td>Float</td><td>Vertex 1 W </td></tr><tr><td>CP13</td><td>V1_C</td><td>Int</td><td>Vertex 1 Color {A, R, G, B} </td></tr><tr><td>CP14</td><td>V1_S</td><td>Int</td><td>Vertex 1 Specular </td></tr><tr><td>CP15</td><td>V1_U</td><td>Float</td><td>Vertex 1 U </td></tr><tr><td>CP16</td><td>V1_V</td><td>Float</td><td>Vertex 1 V </td></tr><tr><td>CP17</td><td>V2_X</td><td>Float</td><td>Vertex 2 X </td></tr><tr><td>CP18</td><td>V2_Y</td><td>Float</td><td>Vertex 2 Y </td></tr><tr><td>CP19</td><td>V2_Z</td><td>Float</td><td>Vertex 2 Z </td></tr><tr><td>CP20</td><td>V2_W</td><td>Float</td><td>Vertex 2 W </td></tr><tr><td>CP21</td><td>V2_C</td><td>Int</td><td>Vertex 2 Color {A, R, G, B} </td></tr><tr><td>CP22</td><td>V2_S</td><td>Int</td><td>Vertex 2 Specular </td></tr><tr><td>CP23</td><td>V2_U</td><td>Float</td><td>Vertex 2 U </td></tr><tr><td>CP24</td><td>V2_V</td><td>Float</td><td>Vertex 2 V </td></tr></tbody></table><br />Once we have programmed the values, writing the 3D_TRIG register from the previous table will start the rendering operation. Then the CPU must wait for the triangle to finish rendering before programming the next one.<br /><br /><i>Per the response from the author in the comments section, there are actually two sets of staging registers that allow the next command to be loaded while the previous one is being processed. The CPU still can only load one triangle at a time and must wait until a triangle finishes to load the next one.</i><br /><br />If you have a lot of triangles, the CPU could spend a significant amount of time updating registers, which is the reason for the display list controller. It's operation is pretty simple: the CPU writes lists of register values into display memory, and the display list controller jams the next ones in from the display list after it processes each command. Since the semantics of the commands are the same with the display list controller (and the rest of the drawing engine operates the same with either method of programming commands), I won't talk about it any more.<br /><br /><h2>Hardware Implementation</h2>Let's start by tracing what happens when the host writes to the GPU control registers. We'll start at <a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/de3d_top.v" target="_blank">hdl/de3d/de3d_top.v</a>. The inputs that deal with the host bus have the hb_ prefix:<br /><br /><pre>   input [31:0]  hb_din,    // Data In<br />   input [8:2]   hb_adr_r,  // Host address<br />   input         hb_wstrb,  // Write Strobe (enable)<br /></pre><br />When we write each register, hb_wstrb (write strobe) goes high, indicating the data on the hb_adr/hb_din signals--which correspond to address and data--are valid. &nbsp;For example, here it writes command parameter 0 (vertex 0 X for a triangle command):<br /><div class="separator" style="clear: both; text-align: center;"><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/--kdYIfSUdSk/V5S7mBcAUGI/AAAAAAAACV4/v2t-rZcw8rcgkwaGv1UVsookHhO1Ad5YACLcB/s1600/waveform.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="157" src="{{ site.url }}/assets/2016-07-24-image-0001.png" width="320" /></a></div><br />The de3d_reg (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/de3d_reg.v" target="_blank">hdl/de3d/de3d_reg.v</a>) module latches the value for all the 3D register parameters. A large chunk of this file consists of nested if/else statements that latch each register. For example, here is the code that latches the X coordinate of vertex 1:<br /><br /><pre>    if (hb_adr==CP9) begin <span style="color: blue;">// V1X</span><br />        if (!hb_ben[0]) vertex1_u`VXB0 &lt;= xy_in[7:0];<br />        if (!hb_ben[1]) vertex1_u`VXB1 &lt;= xy_in[15:8];<br />        if (!hb_ben[2]) vertex1_u`VXB2 &lt;= xy_in[23:16];<br />        if (!hb_ben[3]) vertex1_u`VXB3 &lt;= xy_in[31:24];<br />    end<br /></pre><br />Writing the TRG3D register has the side effect of starting triangle rasterization. The code is in <a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de/der_reg_1.v" target="_blank">hdl/de/der_reg_1.v</a>:<br /><br /><pre><span style="color: blue;">  /***************************************************************************/<br />  /*  LATCH THE COMMAND TRIGGER    */<br />  /***************************************************************************/</span><br /><br />  <span style="color: blue;">// Hit XY1 or CP1 and not in 3D line or Triangle</span><br />  always @* cmd_trig_comb = (!hb_csn &amp;&amp; hb_wstrb<br />        &amp;&amp; (dlp_adr == {XY1_XY0, 1'b1}) &amp;&amp; !hb_ben[3]) ||<br />        (!hb_csn &amp;&amp; <span style="background-color: #fff2cc;">hb_wstrb &amp;&amp; (dlp_adr == {TRG3D_CP24, 1'b1}</span>)<br />        &amp;&amp; !hb_ben[3] &amp;&amp; en_3d);<br /></pre><div><br />The cmd_trig_comb is an output of this module that kicks off a number of state machines that start filling the triangle.<br /><br />Here's a block diagram of the 3D pipeline:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-qzN3G23zSRY/V5TBe-bjmxI/AAAAAAAACWU/JJl-CXtflnQJo175pdWR25z7crz2ZW3RQCLcB/s1600/pipeline.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="104" src="{{ site.url }}/assets/2016-07-24-image-0002.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">Every pipeline stage up to the pixel cache processes up to one pixel per cycle. This is different than VideoCore (and many other modern GPUs), which works on 2x2 quads.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h3 style="clear: both; text-align: left;">Rasterizer</h3><div style="clear: both; text-align: left;">The rasterizer determines which screen pixels a triangle covers.<br /><br /></div><div style="clear: both; text-align: left;">As we saw above, the CPU writes triangle coordinates to the GPU as three x/y raster positions. But the rasterizer uses edge equations. It is the job of the des_grad module (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/des_grad.v" target="_blank">hdl/de3d/des_grad.v</a>) to compute these values (gradients). The des_reg module latched those the vertex positions when the CPU wrote them as described above. All of these values are routed in parallel (488 bits per vertex) into the des_grad module:</div><div style="clear: both; text-align: left;"><pre><span style="color: blue;"> // Vertex Zero, One, and Two.</span><br /> input [447:0] vertex0,<br /> input [447:0] vertex1,<br /> input [447:0] vertex2,</pre>When the CPU initiates triangle rendering after writing the vertex parameters, des_grad begins computing the rasterization coefficients. It has a floating point ALU module (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/math/flt_alu.v" target="_blank">hdl/math/flt_alu.v</a>) that can perform a few operations in parallel. The des_grad state machine drives the ALU block to compute the coefficients for the rasterizer. &nbsp;It takes 42 cycles total to set up one triangle. It writes each coefficient as it computes it back to des_reg, which collects these and outputs them in parallel as a 256 bit wide signal called 'spac_bus'. This connects into the scan converter module, called des_smtri, short for State Machine Triangle (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/des_smtri.v" target="_blank">hdl/de3d/des_smtri.v</a>). As its name implies, this module implements a state machine that sweeps across the triangle, outputting up to one fragment position per cycle:</div><pre>        output reg              t3_pixreq, <br /> output reg signed      [15:0]  cpx,  <span style="color: blue;">// Current position X.</span><br /> output reg signed      [15:0]  cpy,  <span style="color: blue;">// Current position Y.</span></pre>When it has computed a pixel position, it asserts the t3_pixreq signal.<br /><br /><h3>Fragment Generator</h3>The fragment generator (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/des_frag_gen.v" target="_blank">hdl/de3d/des_frag_gen.v</a>) performs the following operations for each pixel sent to it by the rasterizer:<br /><ul><li>Interpolate parameters: U/V texture coordinates or ARGB color parameters, depending if texture or flat shading is enabled.</li><li>Determine <a href="https://en.wikipedia.org/wiki/Mipmap" target="_blank">level of detail</a>&nbsp;(which mip map to use) for texture fetches</li><li>Perform 2D clipping to output rectangle.</li></ul>This module outputs the raster position on screen and a bunch of computed parameters:<br /><pre>   output [15:0]  x_cur_o,      <span style="color: blue;">// Position of pixel</span><br />   output [15:0]  y_cur_o, <br />   output [31:0]  z_cur_fx,     <span style="color: blue;">// Z value for pixel</span><br />   output [19:0]  current_u,    <span style="color: blue;">// Texture coordinate</span><br />   output [19:0]  current_v, <br />   output [31:0]  current_argb, <span style="color: blue;">// Color value (for non-textured triangle)</span><br />   output [23:0]  current_spec, <span style="color: blue;">// Specular highlight</span><br />   output [7:0]   current_fog,  <span style="color: blue;">// Fog value</span><br />   output [3:0]   lod_num,      <span style="color: blue;">// Level of detail (mip map number)</span></pre><div>The current_u and current_v (which are texture coordinates) feed into to the texture cache. The remaining parameters connect to a FIFO which feeds them to the texel pipe.<br /><br /></div><div><h3>Texture Cache</h3><div class="p1">The texture cache (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/lucy_tc/de3d_tc_top.v" target="_blank">hdl/lucy_tc/de3d_tc_top.v</a>) receives U and V texture coordinates from the fragment generator. The push_uv signal goes high when a texel coordinate is available from the previous stage.<br /><pre>   input  push_uv,  <span style="color: blue;">// Push UV.</span><br />   input [10:0] current_u_g1, <span style="color: blue;"> // Upper left texel (U)</span><br />   input [10:0] current_v_g1,  <span style="color: blue;">// Upper left texel (V)</span></pre>If the texel are in the cache, it will assert the 'tc_ready' signal and outputs four adjacent texel color values in parallel.</div><pre> output [31:0] ul_tex,         <span style="color: blue;">// Upper left texel</span><br /> output [31:0] ll_tex,         <span style="color: blue;">// Lower left texel</span><br /> output [31:0] ur_tex,         <span style="color: blue;">// Upper right texel</span><br /> output [31:0] lr_tex,         <span style="color: blue;">// Lower right texel</span></pre>If the texture cache does not have the texel in question, it will stall while it fetches the data from the memory controller. It will assert tc_ready when the data is available. The texture cache supports a number of source color formats and performs color conversion as necessary.<br /><br /><h3>Texel Pipe</h3>If texturing is not enabled, the texel pipe (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de3d/de3d_texel_pipe.v" target="_blank">hdl/de3d/de3d_texel_pipe.v</a>) ignores the output of the texture cache. &nbsp;But let's assume it is for now. When the texture cache asserts the tc_ready signal, the texel pipe will retrieve both the texture color from the texture cache and pop the other fragment parameters out of the FIFO that the fragment generator put them in.<br /><br />The texel pipe performs the following operations:<br /><ul><li>Blend/filter the four raw texels from the texture cache (<a href="https://en.wikipedia.org/wiki/Bilinear_filtering" target="_blank">bilinear filtering</a>).</li><li>Apply fog</li><li><a href="https://www.opengl.org/documentation/specs/version1.1/glspec1.1/node96.html" target="_blank">Alpha reject test</a></li><li>Convert pixel color to destination format (for example, RGB565)</li><li><a href="https://en.wikipedia.org/wiki/Dither" target="_blank">Dithering</a>. The output device only supports 16 bits per pixel, so this was required to compensate for that. Modern output devices support more color depth, so this an obsoleted component.</li></ul>When the texel pipe has a valid computed position, it asserts 'pc_valid' and sends the formatted pixel and position information to the pixel cache:<br /><ul></ul><pre>   output reg [31:0]   formatted_pixel, <span style="color: blue;">// Color to Pixel Cache</span><br />   output reg [7:0]    current_alpha,   <span style="color: blue;">// Alpha to Pixel Cache</span><br />   output reg [15:0]   x_out,           <span style="color: blue;">// X Position</span><br />   output reg [15:0]   y_out,           <span style="color: blue;">// Y Position</span><br />   output reg          pc_valid,        <span style="color: blue;">// Load Pixel Signal to Pixel Cache</span></pre><ul></ul>The Z values from the fragment generator bypass the texel pipe via a FIFO and are delivered to the pixel cache in the same cycle as the other data.<br /><br /><h3>Pixel Cache</h3><div class="p1">The pixel cache is contained in the ded_top module (<span class="s1"><a href="https://github.com/asicguy/gplgpu/blob/master/hdl/de/ded_top.v" target="_blank">hdl/de/ded_top.v</a></span><span class="s2">). It instantiates submodules&nbsp;</span>prefixed 'ded_', which stands for "Drawing Engine Datapath."</div><br />Up until this point in the pipeline, everything has worked on a pixel at a time. But the memory controller works in 128 bit chunks (this GPU was advertised as "128 bit" graphics card, this is presumably what they were referring to). &nbsp;At 16 bits per pixel, that is eight pixels. The pixel cache collects the pixel data and sends a full burst in parallel to the memory controller:<br /><br /><pre>   input   valid_3d,<br />   input [31:0]   pixel_3d,              <span style="color: blue;">// Color data for pixel</span><br />   input [31:0]   z_3d,                  <span style="color: blue;">// Z data for pixel</span><br /><br />   output [BYTES-1:0]  mc_pixel_msk,     <span style="color: blue;">// pixel mask data output</span><br />   output [(BYTES&lt;&lt;3)-1:0] mc_fb_out,    <span style="color: blue;">// Color out</span><br />   output [(BYTES&lt;&lt;2)-1:0] mc_fb_a,      <span style="color: blue;">// Alpha out</span><br />   output [(BYTES*8)-1:0] z_out<br /></pre><br />We can see this in action below. The valid_3d signal indicates when a pixel is ready from the texel pipe. Once all of the pixels are collected, the pixel cache will push all 128 bits of the data (both Z and frame buffer data) out, along with a mask that indicates which pixels were covered. &nbsp;Near the edge of a triangle, it's possible not all eight pixels overlap the triangle, in which case the 8 bit mask will indicate this.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-tqOT3e8gIdk/V6qcmlv1DzI/AAAAAAAACXc/PYSx5K_liOoDQUH_1uXzQI1P9Ov4csGGQCLcB/s1600/pixel-cache-waveform.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="206" src="{{ site.url }}/assets/2016-07-24-image-0003.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"></div><h3>Memory Controller</h3></div></div><div><div><span class="s1"><span class="s1"><span class="s1">The memory controller module (</span></span></span><a href="https://github.com/asicguy/gplgpu/blob/master/hdl/mc_graph/mc.v" target="_blank">hdl/mc_graph/mc.v</a>)&nbsp;<span class="s1"><span class="s1"><span class="s1">combines a number of functions. It</span></span></span>&nbsp;arbitrates access to internal memory from internal sources like the display list processor and the VGA controller. But for our discussion, the important part is performing final operations on the pixels and writing them back to the frame buffer. This includes alpha blending and <a href="https://en.wikipedia.org/wiki/Z-buffering" target="_blank">Z-Buffer</a> checking. These operations require reading existing data from the frame buffer:<br /><ul><li>To get the existing Z value to compare to the newly generated one</li><li>To get the existing color value to be alpha blended with the new one</li><li>To write the old value of pixels that are not covered by the triangle because they are past the triangle edge or fail to the depth test &nbsp;(since the memory controller can write only a full 128 bit burst to memory)</li></ul>The memory controller reads the existing pixels and Z-buffer data from graphics memory, storing them in the mc_mff module (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/mc_graph/mc_mff.v" target="_blank">hdl/mc_graph/mc_mff.v</a>). This presumably happens at the same time the earlier stages of the pipeline are generating pixels. The physical interface to memory is 64 bits wide, so it takes two cycles to read color data and two more to read Z data.<br /><br />When a batch of eight rendered pixels arrives from the graphics pipeline (via pixel cache), and the destination data is available from graphs memory, the mc_dat (<a href="https://github.com/asicguy/gplgpu/blob/master/hdl/mc_graph/mc_dat.v" target="_blank">hdl/mc_graph/mc_dat.v</a>) module performs blending and z-buffer operations on all eight pixels in parallel. The module <a href="https://github.com/asicguy/gplgpu/blob/master/hdl/mc_graph/mc_dat16.v" target="_blank">hdl/mc_graph/mc_dat16.v</a> performs the alpha blending and raster operations for a pixel. You can see here that it instantiates an array of these, one for each pixel:<br /><pre>  mc_dat16 mc_dat<b>[(BYTES/2)-1:0]</b><br />    (<br />     .mclock                (mclock),<br /></pre>mc_dat handles Z-testing. A case statement selects the comparison based on the Z-operation. The loop instantiates logic for each pixel that sets new_z_mask according to the check<br /><pre>  always @(posedge mclock)<br />    if (z_pipe[1])<br />      casex({pix_i[0], z_op_i})<br />        ...<br />        {2'bx1, LESS}:<br />        for (loop0 = 0; loop0 &lt; BYTES/2; loop0 = loop0 + 1)<br />          if (de_zdata_i[loop0*16+:16] &lt; z_store_i[loop0*16+:16])<br />            new_z_mask[loop0*2+:2] &lt;= 2'b00;<br />          else <br />            new_z_mask[loop0*2+:2] &lt;= 2'b11;</pre>After the memory controller processes the pixels, it writes the pixel colors back to the framebuffer in display memory.<br /><br /></div><span class="s1"></span></div>