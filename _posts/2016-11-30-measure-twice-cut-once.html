---
layout: post
title: Measure Twice, Cut Once
date: '2016-11-30T06:01:00.000-08:00'
author: Jeff
tags:
- peformance
- hardware
- microarchitecture
- profiling
- store buffer
modified_time: '2016-11-30T18:23:56.528-08:00'
thumbnail: https://2.bp.blogspot.com/-qQij3s52ofk/WDzn8t77AiI/AAAAAAAACkI/KNkbZLX1pycwawwPTm8LZY9pol2kzjt2wCLcB/s72-c/state-machine.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-9086609968121057848
blogger_orig_url: http://latchup.blogspot.com/2016/11/measure-twice-cut-once.html
---

In a previous&nbsp;<a href="{{ site.baseurl }}{% post_url 2015-02-21-improved-3d-engine-profile %}" target="_blank">post</a>, I observed that, as I increased the number of cores in my <a href="https://github.com/jbush001/NyuziProcessor" target="_blank">GPGPU</a>, performance began to plateau and hardware threads spent more time stalled because their store queue was full. I speculated that the latter might cause the latter, although that wasn't definitive. The current implementation only has a single store queue&nbsp;entry for each thread. One optimization I've been considering is adding more store queue&nbsp;entries, but this has subtle and complex design tradeoffs.<br /><a name='more'></a><br /><h2>Current Implementation</h2>I originally gave an overview of the design of the store buffer in <a href="{{ site.baseurl }}{% post_url 2014-07-04-messy-details %}" target="_blank">this post</a>. I will repeat some of that here, but go into much deeper detail to explore performance tradeoffs and constraints.<br /><br />The level 1 (L1) data cache is "<a href="https://en.wikipedia.org/wiki/Cache_(computing)#Writing_policies" target="_blank">write through</a>." Cores send all memory stores to the shared level 2 (L2) cache. Using a write-through design simplifies <a href="https://en.wikipedia.org/wiki/Cache_coherence" target="_blank">cache coherence</a>, but has more performance overhead. The store queue helps mitigate this. There is an independent store queue&nbsp;for each thread. When a thread performs a store, the store queue latches the address and data. The thread can continue executing without waiting for the store to finish.<br /><br />The store queue (<a href="https://github.com/jbush001/NyuziProcessor/blob/6308a17c4fbfc2ad900562972452dd9e613551ee/hardware/core/l1_store_queue.sv" target="_blank">l1_store_queue.sv</a>), despite being only 300 lines of SystemVerilog, is one of the more complex modules in the hardware design. This is because it needs to enforce a number of implicit consistency guarantees.<br /><br />Each store queue entry can be in one of these states:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-qQij3s52ofk/WDzn8t77AiI/AAAAAAAACkI/KNkbZLX1pycwawwPTm8LZY9pol2kzjt2wCLcB/s1600/state-machine.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="227" src="{{ site.url }}/assets/2016-11-30-image-0000.png" width="320" /></a></div><br /><i>(These identifiers don't appear in the HDL code: the state is encoded by each entry's 'valid' and 'request_sent' bits. I only use these identifiers in this post for clarity).</i><br /><br />A store is in the&nbsp;<span style="text-align: center;">WAIT_L2_SEND</span>&nbsp;state until the L2 cache has accepted it. It may need to wait more than one cycle in this state if other units are sending requests. There are three types of L2 cache requests a core can make: stores, load miss fills for the L1 instruction cache, and load miss fills for the L1 data cache. Each type can enqueue requests from four threads, and has an arbiter that selects one of them each cycle. Another 3 way arbiter selects one of the request types to send to the L2 cache.<br /><div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ULan8oLmEs4/WD41eZMT5kI/AAAAAAAACkY/QoR01t7QpdMR6dIzcyYEmlTV74bdUdjlwCLcB/s1600/arbiter.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="247" src="{{ site.url }}/assets/2016-11-30-image-0001.png" width="400" /></a></div>It is possible--although not likely--for a thread to have all three types of L2 requests pending. This means a core can have up to 4 threads * 3 requests = 12 requests pending. The L2 cache receives requests from all the cores, but can also only accept one request per cycle. There is another arbiter (for this test, 8 inputs) that selects one of the cores to process a request from. This means there can be up to 8 * 12 = 96 requests pending for the L2 cache.<br /><br />There are two cases where the L2 cannot accept new requests:<br /><ul><li>When the L2 cache needs to write back a cache line or load a new one, it puts the requests into queues. If those queues fill up, the L2 cache pipeline will stop accepting new requests.</li><li>When the L2 cache fills a cache miss, it restarts the request that caused at the beginning of the L2 pipeline. During this cycle, it cannot accept requests from cores.</li></ul>Once the L2 cache has accepted store request, it will be in the WAIT_L2_RESPONSE state until the L2 cache finishes processing the request and sends a response.<br /><br /></div>The first software visible effect of the way the store queue&nbsp;is implemented is that <a href="https://en.wikipedia.org/wiki/Consistency_model" target="_blank">memory consistency</a> is relaxed. Lets say we have two functions, each running on a different core:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">volatile int a = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">volatile int b = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void core1()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; a = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; printf("b = %d", b);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">int core2()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; b = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; printf("a = %d", a);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><br />The output of this program is timing dependent. There are a few ways this could run:<br /><ul><li>Both functions assign their variables, then both functions execute their prints. The output would be "a = 1 b = 1"</li><li>core1 executes its print before core2 executes its assignment. The output is "b = 0 a = 1"</li><li>core2 executes its print before core1 executes its assignment. The output is "a = 0 b = 1"</li></ul>At first glance, it might not seem possible for this to output "a = 0 b = 0," because at least one assignment must occur before either of the prints. But this <i>can</i> happen in this implementation if the variable stores are still in the store queue&nbsp;when the load occurs. This design can reorder stores after loads. But only between hardware threads. We guarantee that threads will always see <i>their own </i>stores in order. For example, this program would never print "a = 0."<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">int a = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void core1()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; a = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; printf("a = %d", a);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><br /><div>We can relax consistency between threads because it doesn't affect program correctness when memory isn't shared, and usually memory isn't. But when it is, software needs a way to explicitly specify ordering. This design does that with a&nbsp;<a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank">memory barrier</a>. Here is the original program with barriers added:</div><div><br /></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">volatile int a = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">volatile int b = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void core1()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; a = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp;&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">__sync_synchronize</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">();</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; printf("b = %d", b);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">int core2()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; b = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp;&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">__sync_synchronize();</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; printf("a = %d", a);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span></div><div><br />The __sync_synchronize built-in will,&nbsp;<a href="http://stackoverflow.com/questions/982129/what-does-sync-synchronize-do" target="_blank">among other things</a>, emit a 'membar' instruction on this architecture. The membar instruction suspends the thread until the L2 cache has acknowledged all pending stores for the thread. This ensures the new value of the memory location is visible to all cores. Because of this, it is longer possible for this to print "a = 0 b = 0," because each thread must finish its store before printing the value.</div><br />Calling this design "write through" is misleading. It does not update the L1 data cache immediately when a store occurs. The store is first sent to the L2 cache. When the L2 finishes its update, it broadcasts a message to all cores to update their L1 caches if they contain that cache line. This updates the cache of the originator as a side effect. To ensure the thread sees its own stores before they are in the L1 cache, hardware checks the store queue&nbsp;in parallel with the cache every time it performs a load. If there is a store queued for the load address, it uses that data instead of the data returned from the L1 cache.<br /><br />There's a reason I don't update the L1 cache immediately when the store occurs, even though it would remove the complexity of the bypass logic.<br /><br />First off, doing this creates a new edge condition: a write update could come from the L2 cache the same cycle the core is performing a store. There are a few ways I could handle this:<br /><ul><li>Add another write port to the L1 cache data array. <a href="{{ site.baseurl }}{% post_url 2016-03-01-videocore-qpu-pipeline %}" target="_blank">This post</a> discusses area and power impacts of this. I would still need to handle concurrent updates to the same cache line address.</li><li>Roll the thread back and let the L2 cache update win. The thread would then need to retry its store later. This also adds complexity and runtime overhead.</li></ul>But the most important reason is a subtle problem that would occur because hardware threads on the same core share an L1 data cache. In the next example, we have two functions that store a shared variable, and two functions that read it. Let's assume writer1, writer2, and reader1 run on different cores:<br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">volatile int a = 0;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void writer1()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; a = 1;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void writer2()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; a = 2;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span></div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void reader1()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; while (1)</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; printf("1: a = %d\n", a);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void reader2()</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; while (1)</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; printf("2: a = %d\n", a);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span><br /><br />If writer 2 updates 'a' after writer 1, reader1 will print something like this sequence:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">1: a = 0</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">1: a = 1</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">1: a = 2</span><br /><br />But if reader2 is another hardware thread running on the same core as writer2, and stores updates the local cache immediately, it would be possible for it to print:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 0</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 2</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 1</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 2</span><br /><br />Here's what is happening:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 0</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span style="font-family: &quot;times&quot;;"><span style="color: #666666; font-family: &quot;times&quot; , &quot;times new roman&quot; , serif;"><i>Writer 2 updates the value to its local cache. It's immediately visible to reader 2.</i></span></span></span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 2 &nbsp;</span><br /><span style="color: #666666; font-family: &quot;times&quot; , &quot;times new roman&quot; , serif;"><i>L2 cache finishes processing store from writer 1 and broadcasts write update</i></span><br /><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 1</span>&nbsp; &nbsp;&nbsp;</div><span style="color: #666666; font-family: &quot;times&quot; , &quot;times new roman&quot; , serif;"><i>L2 cache finishes processing store from writer 2 and broadcasts write update</i></span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">2: a = 2</span>&nbsp; <br /><br /><div>This problem is unique to processors that support hardware multithreading.<br /><br />While it looks odd that 'a' flips back to 1 from 2, the real problem is that reader1 and reader2 see the stores in different orders. This violates one of the three rules of <a href="https://en.wikipedia.org/wiki/Cache_coherence#Definition" target="_blank">cache coherence</a>, as described by&nbsp;<a href="https://www.amazon.com/Computer-Organization-Design-Fifth-Architecture/dp/0124077269" target="_blank">Patterson and Hennessy</a>:<br /><blockquote class="tr_bq">Writes to the same location are serialized; that is, two writes to the same location by any two processors are seen in the same order by all processors. For example if the values 1 and 2 are written to a location, processors can never read the value of the location as 2 and then later read it as one.</blockquote>The WAIT_L2_RESPONSE state is necessary to enforce this ordering. If I didn't need to, I could immediately make the store buffer entry available after the L2 has accepted the request. Supporting this ordering has a performance impact, because there are more cases where the thread cannot proceed because it is waiting for the store buffer entry to be available.</div><div><div><br /></div>If the processor attempts a store and there is already one pending in the store queue, the thread will roll back and stall until the first store completes. But if the store is to the same cache line, the store queue may be able to "<a href="https://en.wikipedia.org/wiki/Write_combining" target="_blank">write combine</a>" it. The store queue&nbsp;contains an entire 64 byte cache line. This allows it to perform a block vector store in a single cycle. In my first version of the design, the store queue was only 32-bits wide. It had identical performance to the current design for scalar stores. But it required 16 separate transactions to store a contiguous vector. I widened the store queue and internal busses to to improve memory performance.<br /><br />Because it is possible to store values smaller than 64 bytes, the store queue&nbsp;also contains a mask, where each bit corresponds to a byte in the data field. These indicate that it should update that byte. The store queue&nbsp;entry is 64-byte aligned, so executing a 32-bit scalar store might look like this:</div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-9ot2VlerRBA/WDRS8n1JEXI/AAAAAAAACho/Ev2s3R-UmUYmCZ5txlCH51dbjCR5t2xPwCLcB/s1600/masked_write.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="38" src="{{ site.url }}/assets/2016-11-30-image-0002.png" width="640" /></a></div><br />If another store for the same cache line comes in the store queue&nbsp;has sent it to the L2 cache, it will copy the new data into it. For example, after a second store, the store queue&nbsp;would contain:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-7ilJyRuhcLs/WDRuU1wusQI/AAAAAAAACh8/lA2HrJvOn9smTxmqsOhf5vLMdDw-xuZkwCLcB/s1600/write-combined.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="36" src="{{ site.url }}/assets/2016-11-30-image-0003.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>If it has already sent the store queue&nbsp;entry to the L2 cache, it's too late to write combine it. The thread rolls back and stalls.<br /><br />The store queue&nbsp;also contains cache control commands like flushes and invalidates. These cannot be write combined with normal stores.<br /><br /><ul></ul><div><h2>An Improved Implementation</h2><ul></ul>To summarize, in the current design, a thread will stall waiting on the store queue&nbsp;when:<br /><ul><li>A store is already pending for a different cache line.</li><li>A store is pending for the same cache line, but the store queue has sent it to the L2 cache and is waiting for it to finish.</li></ul>It's hopefully clearer now how multiple store queue&nbsp;entries per thread could improve performance: When a store comes in and can't be write combined with any existing entries, it would use a new one. It would stall only when all the entries are in-use. There are a few high order decisions for this design:<br /><ol><li>What should it do when a thread attempts to load from an address that has a pending store in the store queue?&nbsp;</li><ul><li>Use bypass logic to replace the cache data with the store data (current design), or</li><li>Roll back the thread and stall it until the store completes</li></ul><li>When the store queue has sent an entry to the L2 cache and is waiting for a response, can it send another, or should it wait for the first to complete?</li><li>If the processor does a store that matches the address of a store buffer entry that it has already sent to the L2 cache (but not completed), and thus cannot write combine, does it:</li><ul><li>Roll back and stall the thread until the store completes (current design), or</li><li>Put the store data into a new entry&nbsp;</li></ul></ol>We can't consider these questions independently, because some design impacts result from the interaction between them. For example, if I answer question 1 by saying it should bypass entries, and answer question 3 by saying it should allocate a new entry, I'll need to add logic to potentially bypass every single entry in the queue. Imagine something like this (I'm only showing 32 byte lanes to make this fit):<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://2.bp.blogspot.com/-9B0d6uVHwFg/WDodqRpsaeI/AAAAAAAACjY/trJAZDS4MgYr1jIA3C0ifU9Jm_8ne-I7QCLcB/s1600/bypass.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="254" src="{{ site.url }}/assets/2016-11-30-image-0004.png" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: left;">This implementation would need an n way mux for each of the 64 byte lanes in the store buffer (where n is the number of store queue entries). It would also need logic to determine the appropriate mux sources using modulo wrapping logic. That is much more complex and will have combinational delay that may affect clock speed. Changing only one of these decisions will avoid this.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">A potential advantage to allowing multiple L2 requests to be pending (question 2) is that it could increase throughput, since the store queue&nbsp;could enqueue one request per cycle in the best case.&nbsp;</div><ul><li>But, as I've seen in the past, this advantage may&nbsp;<a href="{{ site.baseurl }}{% post_url 2015-02-28-automatic-cache-prefetching %}" target="_blank">go away</a>&nbsp;when multiple hardware threads are running, because they hide the latency.&nbsp;</li><li>Also, threads&nbsp;<a href="{{ site.baseurl }}{% post_url 2014-07-04-messy-details %}" target="_blank">don't store that often</a>&nbsp;even in memory heavy applications, which erodes the improvement even more.</li></ul><div>This system is complex enough that it's perhaps impossible to predict the performance with real workloads without simulating it somehow. The definitive way to answer these questions would be to implement all all eight combinations and benchmark them against each other, but that would be a lot of work.<br /><br />Rather, I can gather enough data with the existing design and make some educated guesses. The challenge is that the results are often workload dependent, and running the wrong test program may give me a misleading answer. Nonetheless, some assumptions are safer to make. For example, the fact that processors use caches is based on the assumption that memory accesses exhibit&nbsp;<a href="https://en.wikipedia.org/wiki/Locality_of_reference" target="_blank">locality</a>. It's easy to write a program that violates that assumption--by accessing random locations, for example--and performs poorly on any modern processor, but we're willing to accept that for the substantial performance improvement in more common use cases.<br /><br /></div></div><h2>Gathering Data</h2><div>Testing question 1 (how to handle loads when stores are pending) is straightforward. The beauty of HDL simulation is that it's easy to add code to perform event and performance logging. I added this to&nbsp;<a href="https://github.com/jbush001/NyuziProcessor/blob/51c19074fc7118664b0bb10bdffbbd0bb3d25b1c/hardware/core/writeback_stage.sv" target="_blank">writeback_stage.sv</a>:<br /><br /><pre>+    int total_loads;<br />+    int loads_bypassed;<br />+<br />+    always_ff @(posedge clk, posedge reset)<br />+    begin<br />+        if (reset)<br />+        begin<br />+            total_loads &lt;= 0;<br />+            loads_bypassed &lt;= 0;<br />+        end<br />+        else<br />+        begin<br />+            if (dd_instruction_valid &amp;&amp; !dd_instruction.is_cache_control<br />+                &amp;&amp; dd_instruction.is_load &amp;&amp; !wb_rollback_en)<br />+            begin<br />+                total_loads &lt;= total_loads + 1;<br />+                if (sq_store_bypass_mask != 0)<br />+                    loads_bypassed &lt;= loads_bypassed + 1;<br />+            end<br />+        end<br />+    end<br />+<br />+    final<br />+    begin<br />+        $display("%0d total loads %0d bypassed\n", total_loads, </pre><pre>+            loads_bypassed);<br />+    end<br /></pre><br />I ran the 'clip' render test that I used to test scalability in the blog post cited at the beginning of this one. But, unlike that test, I ran it with one core and the default cache size. It gave this output:<br /><br /><pre>ran for 26857296 cycles<br />***HALTED***<br />2746823 total loads 1024 bypassed<br /></pre><br />The low bypass count (0.037% of loads) was a surprise, although I guess it makes sense that the compiler tries to keep things in registers and it would be inefficient for it to load something it just wrote. This suggests, at least in the current design, the load bypass logic is overkill and rolling back the thread in this case would have minimal performance impact. A caveats is that, if there are more store buffers, there are more possibilities for a load conflict. However, it's hard to imagine this being significantly higher.<br /><br />The answer to question 2 depends on timing of stores.&nbsp;<span style="text-align: center;">Stores can be write combined when the entry is in WAIT_L2_SEND from the state diagram earlier, but cannot be write combined in WAIT_L2_RESPONSE, because it has already sent the data to the L2 cache. It would be useful to know how much time store entries spend in these states. If they spend most of their time in WAIT_L2_RESPONSE and little in&nbsp;</span><span style="text-align: center;">WAIT_L2_SEND</span><span style="text-align: center;">, then it would make sense to add later stores to new entries, because there would be few opportunities for write combining.</span><br /><br />I added code to the store buffer to log the amount of time pending entries spend in these states:<br /><br /></div><pre>    genvar thread_idx;<br />    generate<br />        for (thread_idx = 0; thread_idx &lt; `THREADS_PER_CORE; thread_idx++)<br />        begin : thread_store_buf_gen<br /><br />...<br /><br />+            int cycles_wait_send = 0;<br />+            int cycles_wait_response = 0;<br />+            int store_count = 0;<br />+<br />+            always @(posedge clk, posedge reset)<br />+            begin<br />+                if (reset)<br />+                begin<br />+                    cycles_wait_send &lt;= 0;<br />+                    cycles_wait_response &lt;= 0;<br />+                    store_count &lt;= 0;<br />+                end<br />+                else<br />+                begin<br />+                    if (rollback == 0 &amp;&amp; store_requested_this_entry)<br />+                        store_count &lt;= store_count + 1;<br />+<br />+                    if (pending_stores[thread_idx].valid)<br />+                    begin<br />+                        if (pending_stores[thread_idx].request_sent)<br />+                            cycles_wait_response &lt;= cycles_wait_response + 1;<br />+                        else<br />+                            cycles_wait_send &lt;= cycles_wait_send + 1;<br />+                    end<br />+                end<br />+            end<br />+<br />+            final<br />+            begin<br />+                $display("%0d,%0d,%0d",<br />+                    cycles_wait_send, cycles_wait_response, store_count);<br />+            end<br /></pre><div><br /></div>This will print a separate line for each thread because it's in a generate loop. For example:<br /><pre>ran for 19732 cycles<br />***HALTED***<br />7774,3094,441<br />7719,1959,305<br />7150,1750,304<br />7343,1792,306<br />...</pre>For the following benchmarks, I average the results from all threads together. I ran a few tests to confirm these assumptions using a few limiting cases: <br /><div><ul><li>A single thread writes a piece of cached memory repeatedly. This should be the best case (from a store buffer perspective) because there is no external memory transfer or contention among threads to access the L2 cache.</li><li>All threads access a piece of cached memory repeatedly. There is contention among threads so they should spend most of their time in WAIT_L2_SEND.</li><li>Writing memory as quickly as possible. The bottleneck is external memory and it should spend most time in WAIT_L2_RESPONSE.</li></ul><br /><ul></ul><div><h4>Single Thread Writes Cached Memory.</h4>This program uses a single thread to write to cached data in a loop. It writes two addresses on different cache lines to ensure the store buffer doesn't combine the writes. I unroll the loop to minimize branch/loop overhead and ensure it's writing as quickly as possible.</div><div><br /></div><div><pre>    for (i = 0; i &lt; 100; i++)<br />    {<br />        *((volatile int*) region_1_base) = 0x12345678;<br />        *((volatile int*) region_2_base) = 0x12345678;<br />        *((volatile int*) region_1_base) = 0x12345678;<br />        *((volatile int*) region_2_base) = 0x12345678;<br />        *((volatile int*) region_1_base) = 0x12345678;<br />        *((volatile int*) region_2_base) = 0x12345678;<br />        <i>... (20 writes total)</i><br />    }<br /></pre></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;&nbsp;</span><br />The results:<br /><br /></div><div>Total cycles:&nbsp;31,542</div><div>Total stores: 2,137<br /><div>Total cycles in WAIT_L2_SEND:&nbsp;2,139</div><div class="p1">Total cycles in WAIT_L2_RESPONSE: 11,194<br />Total cycles with store pending:&nbsp;13,333<br /><br />Portion of time store buffer is pending: 42%<br />Total cycles per store: 13,333 / 2,137 = &nbsp;<b>6.2</b><br />Cycles in WAIT_L2_SEND per store: 2,139 / 2,137 =&nbsp;<b>1</b><br />Cycles in WAIT_L2_RESPONSE per store: 11,194 / 2,137 =&nbsp;<b>5.2</b><br /><br />It takes 1 cycle to send each store request. They don't need to wait in WAIT_L2_SEND&nbsp;because there's only one writer.<br /><br />In the case of a L2 cache hit, the L2 response takes 5 cycles. This is the best case: the length of the L2 pipeline (4 stages) plus one stage in the core that handles the L2 response. The cycles in WAIT_L2_RESPONSE is pretty close to that number. It is slightly higher probably because of initial cache misses when the program starts.<br /><br /></div></div><h4>All Threads Access Cached Memory</h4>This test is the same as the last one, but I enable all 8 cores and 32 threads running the loop above, writing to the same locations:<br /><br /><div>Total cycles:&nbsp;22,529</div><div>Total stores/thread: 418<br /><div>Total cycles in WAIT_L2_SEND/thread: 9,726</div><div class="p1">Total cycles in WAIT_L2_RESPONSE/thread: 2,421<br />Total cycles with store pending/thread: 12,147<br /><br />Portion of time store buffer is pending: 54%<br />Total cycles per store: <b>29.05</b><br />Cycles in WAIT_L2_SEND per store: <b>23.27</b><br />Cycles in WAIT_L2_RESPONSE per store: &nbsp;<b>5.79</b></div></div><div><br /></div><div>The cycles in WAIT_L2_RESPONSE&nbsp;is still around 5, because these are all cache hits. The total cycles for each L2 request is 29. In the best case, this would be 31, because each thread would wait for all other threads to execute before continuing, but it's smaller presumably because of other overhead (for example, a thread misses its window because it's just rolling back on a branch).<br /><br />WAIT_L2_SEND is only 23 cycles (rather than 28) because when it enqueues its request, there are already around 5 store requests somewhere in the L2 request/response pipeline.<br /><br /><h4>Write Memory as Fast as Possible</h4></div>I modified the <a href="https://github.com/jbush001/NyuziProcessor/blob/6308a17c4fbfc2ad900562972452dd9e613551ee/software/benchmarks/membench/membench.c" target="_blank">membench</a> benchmark to only run the write test. I only used one core with four threads. Each of the thread uses block vector writes to push 64 bytes at a time in an unrolled loop. I configured this with a 128k cache. After it writes the first 128k, every subsequent write will cause it to flush another cache line, so it will be writing continuously.<br /><br /><pre style="font-size: xx-small;"></pre><pre style="font-size: xx-small;"><div style="font-family: times; font-size: medium; white-space: normal;"><br />Total Cycles: 975,515<br /><br />Total cycles in WAIT_L2_SEND<span style="font-family: &quot;times&quot;;">/thread</span>: 8,298<br /><br />Total cycles in WAIT_L2_RESPONSE<span style="font-family: &quot;times&quot;;">/thread</span>: 906,812</div><br /></pre><div>Total cycles with store pending/thread: 915,067<br />Total stores/thread: 8,255<br /><br />Portion of time store is pending: 93.8%<br />Cycles per store: <b>111.9</b><br />Cycles in WAIT_L2_SEND per store: <b>1.005</b><br />Cycles in WAIT_L2_RESPONSE per store: <b>110.85</b><br /><div><br /></div></div><div>As expected, the stores spend all their time in WAIT_L2_RESPONSE. For an L2 cache miss, WAIT_L2_RESPONSE&nbsp;takes an undefined number of cycles, which depends on the number of other queued L2 cache misses and latency to main memory.<br /><div><br /></div>For this case and the last one, adding more store queue entries would not improve performance, because they are hitting bottlenecks. Adding more entries helps where we aren't hitting a bottleneck, but are underutilizing hardware because of variable latencies.<br /><br /></div><h4>Mixed Use Case</h4><div>With that established, I can rerun 'clip' test I mentioned earlier with the new instrumentation. This is the chart from the post I cited at the beginning of this one that prompted this investigation.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-sbNrwrKDtR0/VLaF0QU3K7I/AAAAAAAAB1c/u_Do5NkwIBYWT8O9uRYJLs76q61FL0_bwCPcB/s1600/thread-states.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="318" src="{{ site.url }}/assets/2016-11-30-image-0005.png" width="640" /></a></div><div>For this test, I'm running on 8 cores, 32 threads total. The original experiment increased the size of a 4MB L2 cache. The default cache size for one core is 128k. This would thrash with 32 threads rendering separate tiles. To remove another variable, I had increased the size so the entire working set would fit in the cache. I've done the same here, but this means the time spent waiting for L2 transactions to complete is going to be small and may not represent other workloads.<br /><br />Here are the results:<br /><br /><div>Total cycles: 4,603,805<br />Total stores/thread:&nbsp;79,745<br /><div></div>Total cycles in WAIT_L2_SEND/thread: 502,121</div><div>Total cycles WAIT_L2_RESPONSE/thread:&nbsp;502,859<br /><div>Total cycles waiting on store buffer/thread:&nbsp;1,004,980</div><div></div><br /></div><div>Portion of time store is pending: &nbsp;21.8%<br />Average cycles wait per store: <b>12.6</b><br />Cycles in WAIT_L2_SEND per store: <b>6.3</b><br />Cycles in WAIT_L2_RESPONSE per store: <b>6.3</b></div></div></div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">The number of cycles waiting for the L2 response is around 6, somewhat higher than the best case, cache-hit latency of 5 cycles, but close enough to support the assumption that the L2 cache is large enough to contain the entire working set. WAIT_L2_SEND&nbsp;is just over 6 cycles, so there is contention for the L2 cache because so many threads are performing stores.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">There are about 2.5 million stores across all threads. I added a counter to tally how many stores it combined, which reported 250k, 9.7% of the total. There would be more opportunities for write combining if there were multiple store buffer entries, but is unclear how much.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">This means there are&nbsp;2,303,933 total L2 stores requests. Since each of these takes one bus cycle, this consumes about half of the L2 bandwidth.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">So, would adding store buffer entries improve the performance of this test much? The fact that threads are waiting 6 cycles to send to the L2 interface, yet the L2 interface is busy less than half the time (this includes other response types, which I measured in the original post) suggests yes. It takes several cycles for a thread to restart and queue another store request when it wakes. If that request were already queued, it could issue it immediately. Allowing a thread to continue executing when it has issued a store would allow them to run more often and get on with useful work. The question is how much it would help, and that's hard to calculate directly.</div><div class="separator" style="clear: both;"><br /></div><h2 style="clear: both;">Conclusions</h2>Going back to the three questions I asked earlier:<br /><div><br /></div>1. What should it do when a thread attempts to load from an address that has a pending store in the store queue?<br /><div><br /></div><div>The measurements suggest it should roll back the thread. Loads after stores are infrequent so there isn't a performance win, and it simplifies the implementation not to bypass them.</div><div><br /></div><div>2. When it has sent an entry to the L2 cache and is waiting for a response, can it send another, or should it wait for the first to complete?</div><div><br /></div><div>It is easier to make it send one at a time, and it's not clear there is a big performance win having multiple stores pending. &nbsp;</div><div><br /></div><div>3. If the processor does a store that matches the address of a store buffer entry that it has already sent to the L2 cache (but not completed), and thus cannot write combine, what does it do:</div><div><br /></div><div>This is fuzzier. The data from my last test showed that entries spend at least 50% of their time in the WAIT_L2_RESPONSE state, and even the worst case it is 20%. Only 10% of transactions are write combined for the test workload, but it may increase with more store buffer entries. However, the incremental complexity of doing this seems (at first blush) to be moderate, so it's worth implementing and testing.</div><div><br />I'm don't know how much of a performance win this design change would net. This doesn't seem like a clear win. Unfortunately, it's not easy to know the implications of a non-trivial design decision without implementing and testing it with complex workloads.&nbsp;</div><div><br /></div><div></div><div></div><style type="text/css">p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 14.0px Inconsolata; color: #000000; background-color: #ffffff} span.s1 {font-variant-ligatures: no-common-ligatures} </style></div>