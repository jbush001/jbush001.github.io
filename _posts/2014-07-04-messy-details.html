---
layout: post
title: Messy Details
date: '2014-07-04T09:58:00.000-07:00'
author: Jeff
tags:
- microarchitecture
- performance
- cache coherence
- gpgpu
modified_time: '2015-02-22T07:20:10.838-08:00'
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-7635632076823328356
blogger_orig_url: http://latchup.blogspot.com/2014/07/messy-details.html
---

A problem with books and papers about computer architecture is that they gloss over messy details. The block diagram looks so simple, but, when you begin to implement it, you realize there are fundamental structural hazards. They give no hints about how to handle them. Often, a subtle detail completely alters the design. I'm going to talk about a lot of details around the cache hierarchy, specifically the way the L1 and L2 caches communicate with each other, and a design design with the current microarchitecture I am implementing.<br /><br /><a name='more'></a>There are three rules that a "coherent" cache must obey:<br /><br /><ul><li>If a processor writes to a memory location and later reads back from it, and no other processors writes to that location in between, it must get the same value back.&nbsp;</li><li>When a processor writes to a location other processors must eventually "see" it (read the new value if they access the same address).&nbsp;</li><li>All processors must see writes in the same order--although not necessarily the order written. If one processor reads A then read B from a memory location, another processor cannot read B then read A.&nbsp;</li></ul><br /><div>There are also rules around memory <i>consistency</i> that give additional constraints around when written values become visible, but we'll ignore those for now. Also, this <a href="https://github.com/jbush001/NyuziProcessor" target="_blank">design</a>&nbsp;has multiple hardware threads. It is sufficient to replace 'processor' above with 'hardware thread', which, as far as software is concerned, basically looks like a processor.</div><div><h2>First Generation Microarchitecture</h2></div><div>The first version of the microarchitecture has a write-through L1 data cache. This means memory writes are immediately sent to the L2 cache, which then updates all of the other cores. The design supports multiple processor cores, each with their own independent L1 caches, but the cores share an L2 cache. The write-through design simplifies a lot of things: it adheres to rule 2 automatically because all writes are immediately broadcast. &nbsp;Rule 3 is enforced because the L2 can accept only one request per cycle and they are serialized prior to processing.</div><div><br /></div><div>But here's the first messy detail. The term 'write through' implies that the L1 cache line is updated at the same time the response is sent to the L2 cache. That's not actually the case. &nbsp;If it were, rule #3 would be violated. &nbsp;This is because threads on the same core share the same L1 data cache. Other threads on the same core could see the write before threads on other cores, and the L2 cache may process the transactions in a different order than they become visible.<sup><a href="https://www.blogger.com/blogger.g?blogID=5853447763770338628#footnote1">1</a></sup>&nbsp;</div><div><br /></div><div>Also, having the instruction immediately update the L1 cache would create a structural hazard: the L2 cache could be broadcasting a write update from another cache, or filling a L1 read cache miss in the same cycle, which would result in two things trying to simultaneously update cache memory. This could be resolved by either adding another write port to the SRAM that contains L1 data--increasing the area--or having one of these transactions fail and retry--which adds complexity. It would also need to reconcile the case where both ports simultaneously wrote to the same location. Making the L1 cache only be updated by the L2 cache resolves this problem very neatly. In fact, this is how OpenSPARC works.</div><div><br />The design uses a store buffer. When a write occurs, the store value is latched into a per-thread register. This actually services multiple purposes:</div><div><ol><li>It buffers write requests until they can be sent to the L2 cache. Since there are multiple nodes that can access the L2, potentially attempting in the same cycle, there are cases where the core must wait to send the request.</li><li>It improves performance by allowing the thread to continue running after a store is buffered. &nbsp;Subsequent reads check the store buffer and bypass the data if the address matches the written address (this enforcing rule #1). &nbsp;If another store occurs before the first store is acknowledged, the thread is rolled back and suspended.</li></ol><div>At first blush, it seems like this design should perform poorly. &nbsp;Every write instruction has to go through the L2 interconnect, contending with other cores, and potentially suspending the thread. &nbsp;The reason it doesn't is because writes tend to be relatively infrequent. To demonstrate this, I compiled chunks of C code from a number of programs (these are actually used as C compiler tests in the tests/compiler directory) for this architecture and ran them in the functional simulator. I divided the total number of instructions executed by the number of store instructions. &nbsp;The results are here:</div></div><br /><table border="1" cellpadding="0" cellspacing="0" dir="ltr" style="border-collapse: collapse; border: 1px solid #ccc; font-family: arial,sans,sans-serif; font-size: 13px; table-layout: fixed;"><colgroup><col width="100"></col><col width="75"></col></colgroup><tbody><tr style="height: 21px;"><td style="padding: 2px 3px 2px 3px; vertical-align: bottom;"></td><td data-sheets-value="[null,2,&quot;Instructions per store&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">Instructions between stores</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;Fannkuch&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">Fannkuch</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,7.272167107024708]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">7</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;DCT&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">DCT (libjpeg)</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,8.585766423357665]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">9</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;MD5&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">MD5 (ref impl)</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,12.244203256043415]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">12</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;adler32&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">adler32 (zlib)</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,12.428571428571429]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">12</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;LZSS&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">LZSS (zlib)</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,13.516332660627963]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">14</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;qsort&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">qsort</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,14.132075471698114]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">14</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;AES&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">AES (ref impl)</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,20.74778761061947]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">21</td></tr><tr style="height: 21px;"><td data-sheets-value="[null,2,&quot;crc16&quot;]" style="padding: 2px 3px 2px 3px; vertical-align: bottom;">crc16</td><td data-sheets-formula="=R[0]C[1]/R[0]C[2]" data-sheets-numberformat="[null,2,&quot;0&quot;,1]" data-sheets-value="[null,3,null,28.333333333333332]" style="padding: 2px 3px 2px 3px; text-align: right; vertical-align: bottom;">28</td></tr></tbody></table><br /><div>For example, the DCT example issues a store on average every 9 instructions. &nbsp;Even Fannkuch, which is fairly memory intensive, only issues a store every 7 instructions. &nbsp;When you consider that the processor does not fully utilize the pipeline (at best around 80% of cycles issue instructions; the others don't because of one sort of conflict or another), the actual interconnect utilization for writes is even lower. When running the teapot renderer from previous posts in Verilog simulation, I see a store request every 16 cycles on average.</div><div><h2>Next Generation</h2></div><div>When I began implementing the second generation microarchitecture, I immediately chose a write-back L1 data cache because I felt it would improve performance and scale to higher core counts. &nbsp;Admittedly, although I was aware of the fact that writes are fairly infrequent, I didn't spend much time collecting data to prove that it would benefit this design.<br /><br />A write-back cache introduces a lot of extra complexity, because there is now the potential for caches to have multiple copies of the same memory address in them. A more complex protocol is required to ensure these stay in sync. &nbsp;I chose a snooping MSI protocol&nbsp;with a unidirectional ring bus. A ring bus requires relatively small area and allows high clock speeds because there are only point to point links between adjacent nodes. &nbsp;However, the ring bus adds its own wrinkles: nodes can see messages in different orders depending on where they are relative to the sender in the ring.<sup><a href="https://www.blogger.com/blogger.g?blogID=5853447763770338628#footnote2">2</a></sup> There is also a delay for messages that are broadcast around the ring, which creates more potential race conditions.</div><div><br /></div><div>Despite that, I was fairly pleased with my initial progress. &nbsp;I got a single core executing the 3D rendering engine correctly in simulation, and implemented the cache coherence protocol and state machine. That's when I started running into implementation details...</div><br /><b><u>Livelock&nbsp;</u></b>&nbsp;In this design, when a cache miss is satisfied, the memory instruction is not immediately retired. Instead, the thread that caused the miss is restarted and allowed to retry its operation. &nbsp;There are a few cycles between the cache line being ready and the thread accessing the cache the operation. If the cache line is evicted during that time, the operation will miss the cache again. &nbsp;In the worst case, two cores trying to write the same cache line could ping pong forever, each invalidating the other then hitting a cache miss.<br /><br />The first generation microarchitecture has a similar issue, but the write-back coherence protocol exacerbates it. In a write-back protocol, there can be only one cache in the system that has a modified cache line. When a processor wants to write to an address, it must send a message--a 'write invalidate'--to remove all other copies. In a write-through architecture, writes always make progress and read cache lines are only evicted by other read misses (since the number of hardware threads is the same as the number of cache ways, it's probably impossible, but I haven't formally proven that).<br /><br />There are a few ways of addressing the livelock issue in a write-back architecture:<br /><div><ol><li>Apply the write during the same cycle a miss is satisfied so a thread always makes progress. &nbsp;On the write side, the store data can be latched in the L1 miss queue and applied to the incoming cache line when it is copied from the L2 to the L1 cache. On the read side, this gets tricker because the L2 data may come in the same cycle another instruction is writing back to the register file. &nbsp;OpenSPARC handles this by having two write ports to the register file. &nbsp;The second is shared with the multi-cycle hardware divider unit. I'd rather not burn an extra register file port just for this edge case.</li><li>I also considered having some method of locking the lines into the cache until the instruction that caused the cache miss returns. This adds some additional complexity, especially around LRU tracking.</li></ol></div><div><b><u>Ring flow control</u>&nbsp;</b>Imagine a case--and this is not uncommon--where a processor begins flushing a large number of modified cache lines its L1 data cache. The processor can do this much faster than the L2 cache can write back to the system memory interface (which can required hundreds of cycles). At some point, the thread doing the flushing needs to be suspended. &nbsp;However, there is no easy way to do this. &nbsp;The L2 cache could send some kind of NACK message back, but it would need to track this and be able to resend another message later to cause the processor to resume execution.</div><div><br />The write-back design also increases area: the L1 tags and data need to be dual ported to properly support snooping.<br /><h2>Conclusion</h2></div><div>There is value in keeping the design simple. &nbsp;The write back protocol is a mess of special cases. &nbsp;Attempting to verify it's correctness is challenging. However, part of me doesn't want to abandon it because I've gotten pretty far along and I'm admittedly kind of enamored with the complexity of it. And, scalability is a pretty important design aspect for a processor like this. However, I should probably do a little more modeling and simulation to prove that the performance gain is really worth it. A lot of manycore designs have an L2 cache per core (rather than sharing the L2) and implement coherency between L2 caches. &nbsp;There may be other bottlenecks that limit scalability in a shared L2 design. A hybrid design may also be a better alternative: clusters or four or eight cores could each share an L2 cache and use a write-through protocol, then the L2 caches could implement a write-back coherence protocol underneath.<br /><br /></div><hr /><a href="https://www.blogger.com/null" name="footnote1">1</a>&nbsp;Imagine two cores, A and B, each with two threads 1 &amp; 2. Thread A1 writes the value 0xcc to address 0.  In the same cycle, thread B1 writes the value 0x33 to the same location. The L2 cache sends the updates in order: 0xcc, then 0x33.  Thread A2 would see the writes in order 0xcc, then 0x33.  However, thread B2 would see 0x33, 0xcc, 0x33.<br /><a href="https://www.blogger.com/null" name="footnote2">2</a>&nbsp;Consider a ring that has four nodes A -&gt; B -&gt; C -&gt; D.  Messages flow to the right, one station each cycle, with the output of D looping back to A.  Now, in one cycle both A and C simultaneously insert messages into the ring. Node B will first see the message from A, then the message from C after it loops around. &nbsp;However, node D will first see the message from C, then 2 cycles later, the message from A.