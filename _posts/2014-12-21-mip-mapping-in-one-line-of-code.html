---
layout: post
title: Mip-Mapping
date: '2014-12-21T21:43:00.000-08:00'
author: Jeff
tags:
- mipmapping
- gpgpu
- rendering
modified_time: '2016-03-19T18:36:25.681-07:00'
thumbnail: https://2.bp.blogspot.com/-eqYymIU33FY/VJeQrqPUlhI/AAAAAAAABwA/JBJRGIFFq6k/s72-c/reference.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-3423271450809267509
blogger_orig_url: http://latchup.blogspot.com/2014/12/mip-mapping-in-one-line-of-code.html
---

I added mipmapping support to the software renderer for my&nbsp;<a href="https://github.com/jbush001/NyuziProcessor" target="_blank">GPGPU</a>&nbsp;project.<br /><br /><a name='more'></a><br />Here's a quick test image. This is a simple checkerboard rendered onto a square that has been stretched far into the Z direction.<br /><br /><a href="http://2.bp.blogspot.com/-eqYymIU33FY/VJeQrqPUlhI/AAAAAAAABwA/JBJRGIFFq6k/s1600/reference.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em; text-align: center;"><img border="0" height="300" src="{{ site.url }}/assets/2014-12-21-image-0000.png" width="400" /></a><br /><br />I've drawn each mip level with a different color in this experiment so it's clear where it switches levels. The TextureSampler maintains an array of texture surfaces, with each one being half the size of the previous one. &nbsp;This formula determines which source level to use:<br /><br /><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">int mipLevel = __builtin_clz(int(1.0f / fabs(u[1] - u[0]))) - fBaseMipBits;</span><br /><div><br /></div><div>The first interesting part of the equation is here:</div><div><br /></div><div><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">int mipLevel = __builtin_clz(int(1.0f / <b style="background-color: #f4cccc;">fabs(u[1] - u[0])</b>)) - fBaseMipBits;</span></div><div><br /></div><div>Hardware GPUs generally process pixels in <b>quads</b>: 2x2 grids of pixels. &nbsp;One of the reasons for this is that it makes it easier to determine the proper mip level. This renderer works in groups of 4x4 pixels, 16 at a time, the size of each vector register. &nbsp;The pixels are mapped to vector lanes as follows:</div><div><br /></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;0 &nbsp;1 &nbsp;2 &nbsp;3&nbsp;</span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;4 &nbsp;5 &nbsp;6 &nbsp;7</span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;8 &nbsp;9 10 11&nbsp;</span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">12 13 14 15</span></div><div><br /></div><div>The 'u' and 'v' parameters are passed into the texture sampler. &nbsp;They are 16 element vectors that have the horizontal (u) and vertical (v) coordinates for each source texel. &nbsp;&nbsp;</div><div><br /></div><div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;void TextureSampler::readPixels(vecf16_t u, vecf16_t v, ...</span></div></div><div><br /></div><div>By subtracting the horizontal coordinate of pixel 0 from pixel 1, we find the horizontal distance between two adjacent texels in <i>texture coordinate space</i> (0.0 to 1.0).&nbsp;</div><div><br /></div><div><i>Note that the bracket operator extracts the vector lane using a special instruction. U and V are vector registers, not arrays.</i></div><div><br /></div><div>I've taken a few shortcuts with this computation:</div><div><ul><li>I'm only looking at the distance horizontally, which may choose a suboptimal level if it is stretched more in one direction than another. &nbsp;Most hardware implementations look at both horizontal and vertical.</li><li>I apply the same mip level to all 16 pixels based on the distance only of the top two. Most traditional GPUs apply levels independently for each 2x2 quad.</li></ul>The next step is to convert from the texture coordinate system (0.0 to 1.0) to the raster coordinate space for the source texture. Of course, we need to pick the correct source texture first. &nbsp;I would like the distance between the two adjacent pixels in the destination to be close to one texel in the source mipmap. I can compute the horizontal adjacentTexelDistance using this formula:</div><div><br /></div><div>&nbsp; &nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;</span><span style="font-family: inherit;">adjacentTexelDistance = fabs(u[0] - u[1]) * sourceMipMapWidth&nbsp;</span></div><div><br /></div><div>I can reverse this and find the source mip map width that would have a distance of one texel. &nbsp;Setting adjacentTexelDistance to 1 and dividing both sides by the distance between the two texels:</div><div><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp;&nbsp;</span><span style="font-family: inherit;">sourceMipMapWidth&nbsp;= 1.0 / fabs(u[0] - u[1])</span></div><div><br /></div><div>Which we see in the formula above:</div><div><br /></div><div><div><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">int mipLevel = __builtin_clz(int(<b style="background-color: #f4cccc;">1.0f /&nbsp;fabs(u[1] - u[0])</b>)) - fBaseMipBits;</span></div></div><div><br /></div><div>This is the ideal source mip map width in pixels. This must be rounded to the closest power-of-two texture size. &nbsp;The count leading zeroes instruction does this in one cycle after first converting the width to an integer. This is effectively a logarithm base-2.</div><div><br /></div><div><div><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">int mipLevel = <b style="background-color: #f4cccc;">__builtin_clz(int</b>(1.0f /&nbsp;fabs(u[1] - u[0])<b style="background-color: #f4cccc;">))</b> - fBaseMipBits;</span></div></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;"><br /></span></div>Now, it needs to express that as an index into the source texture array. &nbsp;I precomputed log2 of the largest texture size when the sampler was initialized by calling count leading zeroes on the largest mip map width, and stored it in fBaseMipBits. Subtracting that effectively divides by the size because these are logarithms.<br /><br /><div><span class="Apple-tab-span" style="white-space: pre;"> </span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;">int mipLevel =&nbsp;__builtin_clz(int(1.0f /&nbsp;fabs(u[1] - u[0])))<span style="background-color: #f4cccc;">&nbsp;</span><b><span style="background-color: #f4cccc;">- fBaseMipBits</span>;</b></span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace; font-size: x-small;"><br /></span></div><div>There are a few more lines of code after the mip level is computed. It must clamp to the bounds of the array (the computed mip level will be negative if a larger texture than the one provided would provide more detail):<br /><br /></div><div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>if (mipLevel &gt; fMaxMipLevel)</div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span class="Apple-tab-span" style="white-space: pre;">     </span>mipLevel = fMaxMipLevel;</div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>else if (mipLevel &lt; 0)</div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span class="Apple-tab-span" style="white-space: pre;">     </span>mipLevel = 0;</div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><br /></div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span style="font-family: &quot;times&quot;; font-size: small;">Finally, it can select the source surface:</span></div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><br /></div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>Surface *surface = fMipSurfaces[mipLevel];</div><div style="font-family: 'Courier New', Courier, monospace; font-size: small;"><br /></div><div>From there, it sample pixels and blends the same way the non-mipmapped version did.<br /><br />The following images show the difference with some more interesting textures. &nbsp;The top image shows the result with no mipmapping. &nbsp; There is a lot of noise in the more distant pixels. This is aliasing that occurs because we are sampling at too low a frequency. The second image shows mipmapping enabled. It's subtle, but you can see that the image looks much smoother as it recedes into the distance.<br /><br /><a href="http://4.bp.blogspot.com/-WXU5-_iIZGQ/VKnS2nrpF6I/AAAAAAAABzE/6JsKxXOZleg/s1600/nomip.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em; text-align: center;"><img border="0" src="{{ site.url }}/assets/2014-12-21-image-0001.png" /></a><br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-9ORKUfOnLeA/VKnS2jvlEZI/AAAAAAAABzA/2ki0u2av0mk/s1600/mipmap.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2014-12-21-image-0002.png" /></a></div></div></div><div><br /></div>I'm still considering whether to implement a full hardware texture unit or perhaps specialized instructions to accelerate texture blending, but first I'd like to do more performance characterization of the fully software texture sampler.<br /><br />