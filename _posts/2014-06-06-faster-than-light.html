---
layout: post
title: Faster than light
date: '2014-06-06T09:16:00.000-07:00'
author: Jeff
tags:
- performance
- gpgpu
- superscalar
modified_time: '2015-01-04T08:06:10.859-08:00'
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-4679104616393298010
blogger_orig_url: http://latchup.blogspot.com/2014/06/faster-than-light.html
---

In the last post, I discussed the fastest possible execution time of a test program, the "speed of light," as it were. There was an important assumption in this calculation: that the CPU issued one instruction per cycle. A common technique to improve performance in modern processors is issuing multiple instructions in the same cycle, also known as superscalar. I hadn't put much thought into a superscalar design given the focus on utilizing the wide vector unit. However, some helpful comments in a <a href="{{ site.baseurl }}{% post_url 2013-12-01-evaluating-instruction-set-tradeoffs %}" target="_blank">previous post</a>&nbsp;have led me to reconsider this decision.<br /><br /><a name='more'></a><br /><br />In this design, there are 16 arithmetic pipelines, one for each vector lane. For scalar operations, the result from the lowest vector lane is used. When a scalar operation is issued, the vector unit is not utilized for that cycle. I instrumented the system and found that for many tests, the vector unit is underutilized. Ideally, we'd like to keep it as busy as possible with wide operations. Scalar operations are often just maintenance operations, such as updating loop counters or advancing pointers. &nbsp;So, an approach to improving performance would be to have a separate pipeline to allow co-issuing these types of simple instructions in parallel with vector instructions.<br /><br />There are habits that I've developed as a software engineer that sometimes hinder my efforts designing hardware. I encountered this when thinking about how to implement this feature. In software, there is a focus on refactoring and trying to utilize common code. A hallmark of good software design is reuse of mechanisms. I spent time thinking about how to separate out the scalar unit, but assumed all scalar operations would use it.<br /><br />In hardware, redundancy can often improve performance. &nbsp;One insight is that an additional pipeline could be made simpler (for example, integer only) and used <i>only</i> for co-issued instructions. Normally issued scalar instructions would continue to use the lowest vector pipeline. This would consume a relatively small amount of area.<br /><br />However, implementing this and getting it working correctly would require a fair amount of work. &nbsp;It would be nice to explore the potential performance improvement of various design alternatives before implementing it at the RTL level.<br /><h3>The Functional Simulator</h3><div>One of the first things I wrote when I first started working on this GPGPU was the functional simulator (located in&nbsp;tools/emulator). The simulator, written in C, is <i>instruction accurate</i> but not <i>cycle accurate</i>. &nbsp;It models instruction execution properly, but doesn't bother simulating caches, pipeline hazards, or other implementation details. The functional simulator is a very useful tool:</div><div><ul><li>As a development platform for target software. &nbsp;It is much faster than Verilog simulation, which may take minutes to run a program, and much easier to&nbsp;set up and&nbsp;debug programs than FPGA. It features a&nbsp;simple debugger that can set breakpoints, single step, and inspect memory and registers.&nbsp;</li><li>To run <a href="https://github.com/jbush001/GPGPU/tree/master/tests/compiler" target="_blank">whole-program compiler tests</a>. &nbsp;A program (for example, AES encrypt/decrypt) is compiled using the target toolchain, run in the simulator, and its output is compared to expected patterns.</li><li>As a golden reference for <a href="https://github.com/jbush001/GPGPU/tree/master/tests/cosimulation" target="_blank">hardware verification</a>. This is sometimes called co-simulation or co-verification. The Verilog model is instrumented to dump instruction side effects and the simulator compares them to its own execution. Using this mechanism, I can run long sequences of randomly generated instructions to root out race conditions and hardware bugs. Since the simulator is simpler, it's easier to verify its correctness (or, at very least, the bugs in the simulator are likely to be different than bugs in the hardware model).</li><li>For computing rough performance metrics. &nbsp;It's trivial to add performance counters to the code or print out when certain events occur.&nbsp;</li></ul></div><div>It is in the last capacity that we will use the simulator for this experiment.</div><div><h3>Results</h3></div><div>I added a chunk of code in the simulator to check that two adjacent instructions could be co-issued. Note that I don't actually simulate co-issuing them, I just increment a counter when they could be. &nbsp;Here's the place where instructions are normally interpreted:<br /><br /><pre> int retireInstruction(Strand *strand)<br /> {<br />  unsigned int instr;<br /> <br />  instr = readMemory(strand, strand-&gt;currentPc);<br />  strand-&gt;currentPc += 4;<br />  strand-&gt;core-&gt;totalInstructionCount++;<br /> <br />+ checkCoIssue(instr, readMemory(strand, strand-&gt;currentPc + 4));<br /></pre><br />I just added some code to check if the instructions are compatible. &nbsp;The following rules are currently used:<br /><ul><li>The first instruction must have two vector operands and no mask (because masks are stored in scalar registers, we would not have enough read ports to issue both at the same time)</li><li>The second instruction must have two scalar operands</li></ul><br /><pre>int coIssued;<br /><br />void checkCoIssue(unsigned int instr1, unsigned int instr2)<br />{<br /> int fmt1 = -1;<br /> int fmt2 = -1;<br /> int op2;<br /> <br /> if ((instr1 &amp; 0xe0000000) == 0xc0000000)<br />  fmt1 = bitField(instr1, 26, 3);<br /> else if ((instr1 &amp; 0x80000000) == 0)<br />  fmt1 = bitField(instr1, 28, 3);<br /><br /> if ((instr2 &amp; 0xe0000000) == 0xc0000000)<br /> {<br />  fmt2 = bitField(instr2, 26, 3);<br />  op2 = bitField(instr2, 20, 6);<br /> }<br /> else if ((instr2 &amp; 0x80000000) == 0)<br /> {<br />  fmt2 = bitField(instr2, 28, 3);<br />  op2 = bitField(instr2, 23, 5);<br /> }<br /> <br /> if (fmt1 == 4 &amp;&amp; fmt2 == 0 &amp;&amp; op2 &lt;= 0x1f)<br />  coIssued++;<br />}<br /></pre><br />For this test, I used a simple benchmark that roughly simulates bitcoin hashing (located in benchmarks/hash):<br /><br /><pre>hash&gt; ../../tools/simulator/simulator WORK/program.hex <br />463332 total instructions executed<br />394464 vector instructions<br />10272 coissued<br /></pre><pre></pre><pre><span style="font-family: Times; white-space: normal;"><br /></span></pre><pre><span style="font-family: Times; white-space: normal;"><br /></span></pre><pre><span style="font-family: Times; white-space: normal;">Without any changes, this program does fairly well with vector unit utilization: over 85% of instructions are vector instructions. &nbsp;When the coissue pipeline is added about 2.2% of the instructions are now issued in parallel. &nbsp;This is not a huge improvement. &nbsp;</span></pre><pre><span style="font-family: Times; white-space: normal;"><br /></span></pre><pre><span style="font-family: Times; white-space: normal;">My next experiment was to add another scalar read port. &nbsp;This would allow masked instructions (which this benchmark does not use) and vector instructions with scalar operands to be co-issued with scalar-only instructions. To simulate this, I just changed the criteria for fmt1 above. &nbsp;Here are the results:</span></pre><pre></pre><pre></pre><pre></pre><pre>hash&gt; ../../tools/simulator/simulator WORK/program.hex <br />463332 total instructions executed<br />394464 vector instructions<br />29444 coissued<br /></pre><pre><span style="font-family: Times; white-space: normal;"><br /></span></pre><pre><span style="font-family: Times; white-space: normal;"><br /></span></pre><br />That's a little more interesting. &nbsp;Now over 6% of instructions are co-issued.<br /><h3><span style="font-family: Times;"><span style="white-space: normal;">Conclusions</span></span></h3></div><div><span style="font-family: Times;"><span style="white-space: normal;">It should be noted that these tests don't consider other pipeline hazards that would arise from co-issued instructions. &nbsp;The actual performance improvements would potentially be smaller than this. &nbsp;Also, running with only one benchmark can be misleading. One area I do need to work on is building a larger suite of performance tests.&nbsp;</span></span>There are a number of areas to investigate further:</div><div><ul><li>Allowing more instruction types to be co-issued. &nbsp;One idea would be to have the simulator tabulate joint probabilities for all possible instruction pairs in a few test workloads. &nbsp;This would give an indication of which pairings would be most beneficial.</li><li>Modifying&nbsp;<a href="http://llvm.org/docs/WritingAnLLVMBackend.html#instruction-scheduling" target="_blank">instruction scheduling</a>&nbsp;for the the compiler backend to obtain better pairing</li></ul></div><div><span style="font-family: Times;"><span style="white-space: normal;"><br /></span></span></div><div><span style="font-family: Times;"><span style="white-space: normal;"><br /></span></span></div>