---
layout: post
title: Branch Prediction
date: '2012-11-11T09:51:00.000-08:00'
author: Jeff
tags:
- microarchitecture
- performance
- gpgpu
- branch prediction
modified_time: '2016-04-11T07:12:43.803-07:00'
thumbnail: https://2.bp.blogspot.com/-wWkQMzEg5as/UMN9bRV8RDI/AAAAAAAAAlM/n6WamzTLej0/s72-c/chart_1+(1).png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-393823886523216834
blogger_orig_url: http://latchup.blogspot.com/2012/11/branch-prediction.html
---

I've been designing a simple&nbsp;<a href="https://github.com/jbush001/GPGPU" target="_blank">GPGPU</a> in my spare time. I recently implemented&nbsp;branch prediction, but when I ran the small suite of benchmarks I had written for it, I found that it only improved performance by a few percent. This may seem a bit puzzling at first blush because the benefits of branch prediction are well known. Was there a bug in my implementation? As it turns out, the answer is no, but the reason why is interesting.<br /><br /><a name='more'></a><br />Here are the results of a very simple benchmark, which&nbsp;copies a 2kbyte chunk of memory from one area to another.&nbsp;I ran two versions of this in Verilog simulation, the results of which are shown in the chart below (lower is better).<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-wWkQMzEg5as/UMN9bRV8RDI/AAAAAAAAAlM/n6WamzTLej0/s1600/chart_1+(1).png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2012-11-11-image-0000.png" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">The top set of bars use&nbsp;a single hardware thread to perform the entire copy (2048 bytes). The bottom set of bars, like many of the benchmarks I was using, makes heavy use of hardware multithreading. &nbsp;It&nbsp;divides the region into four equally sized areas and uses a separate hardware thread to copy each one. The multi-threaded version beats the single threaded one handedly despite doing the same amount of work with the same number of execution units. There are a number of well documented reasons for this, but what is interesting is that branch prediction seems to have a very small impact in the multi-threaded case. &nbsp;In the single threaded case, branch prediction improves the performance by 20%, but, in the multi-threaded case, it helps by&nbsp;only around&nbsp;3%. &nbsp;</div><div class="separator" style="clear: both; text-align: left;"><br /></div><h2>Why Is It Guessing?</h2>To analyze the performance if this benchmark, it is necessary to understand what branch prediction is and how it is implemented in this design.&nbsp;The term "prediction" implies there is a chance of being wrong. It may seem a bit strange that the processor must guess whether a branch is taken and does not just know, but it is actually a consequence of pipelining.&nbsp;This is a diagram of the first four stages of the execution pipeline:<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><span style="font-family: &quot;arial&quot; , &quot;helvetica&quot; , sans-serif; margin-left: 1em; margin-right: 1em;"><a href="http://4.bp.blogspot.com/-uVeLvQt2RLg/UJ7uKM7rUlI/AAAAAAAAAec/16RDMRASpzg/s1600/pipeline.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="281" src="{{ site.url }}/assets/2012-11-11-image-0001.png" width="640" /></a></span></div><br />There are four hardware threads in this architecture, which I generally refer to as strands to avoid confusion with software threads. Each strand has its own program counter and executes independently: from a software perspective it looks like an separate processor. However, the strands actually share most of the pipeline in a&nbsp;time-sliced&nbsp;manner.&nbsp;Each cycle the following operations occur:<br /><ul><li>The instruction fetch stage sends one of the &nbsp;program counters to the instruction cache and enqueues the result from the previous cycle into a per-strand instruction FIFO (the instruction cache returns results one cycle after they are requested).</li><li>The strand select stage&nbsp;picks one of the strands from which to issue an instruction to the decode stage.&nbsp;</li><li>The decode stage&nbsp;extracts the register indices from the instruction, based on the type, and issues those to the register file along with the strand id (there is a separate set of registers for each strand).</li><li>The register operands are returned from the register file&nbsp;to the execute stage, which also bypasses results from later stages that have not yet been written back to the register file.&nbsp;</li></ul>There are flip flops between each of these operations and each step takes a clock cycle to complete, so the instructions march down the pipeline one stage at a time.<br /><br />The processor decides whether conditional branches should be taken based on values that are stored in registers. However, those register values are not returned&nbsp;until the execute stage, four cycles after the instruction has been fetched. In order to fetch the next instruction each cycle, the fetch stage must predict the next instruction address. &nbsp;If it guesses incorrectly, the processor will need to roll back the state of the pipeline to where it was before the branch and then start fetching from the proper address.&nbsp;It does this by "squashing" instructions in the pipeline that were issued after the mispredicted branch. Because instructions don't update program state, by writing back to the register file or memory, until the last two stages of the pipeline (which are not shown in this diagram), it is sufficient just to convert these instructions into no-operation instructions and let them proceed down the pipeline.<br /><br />The original implementation of the instruction fetch unit grabbed the instruction from the next sequential memory address (pc + 4) each time an instruction was sent down the pipeline. &nbsp;This was simple and adequate, allowing a new instruction to be issued each cycle. This could be thought of as a form of branch prediction called "predict never taken." &nbsp;This scheme guesses wrong for most branches--even when the branch is unconditional. &nbsp;<i>(Note that I will continue to refer to that sceme as "no branch prediction" in the charts and descriptions on this page)</i><br /><br /><a href="https://github.com/jbush001/VectorProc/commit/57d5318452179b5aca38243db1e339c786b8ae9c" target="_blank">Implementing</a> branch prediction was relatively straightforward: some decode logic was added to the instruction fetch stage which inspects the instruction to determine if it is a branch, and then determines whether it should set the next PC to the branch destination or the next instruction.&nbsp;For conditional branches, the instruction fetch unit uses a simple static prediction scheme that is optimized for loops: if the branch is backward, it predicts that the branch will be taken. &nbsp;If the branch is forward, it predicts that it will not be taken. <br /><h2>Where Does the Time Go?</h2><div class="separator" style="clear: both; text-align: left;">To visualize better why branch prediction has different behavior in a multi-threaded environment, let's imagine&nbsp;a simplified program with three instructions in a loop:</div><blockquote class="tr_bq"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">1 do something<br />2 do something else<br />3 if r1 goto 1<br />4 ...</span></blockquote>Let's assume that the branch instruction 3 is taken most of the time.&nbsp;This diagram shows the execution of the program in a single-threaded pipeline with and without branch prediction. &nbsp;The horizontal axis represents time and the vertical axis shows the decode, and execute stages. &nbsp;Each number represents the program counter of the instruction in that stage:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-8Vf0hETVOV4/UKMSoXajujI/AAAAAAAAAhw/SoxTDRZjxtQ/s1600/Screen+Shot+2012-11-13+at+7.40.01+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="78" src="{{ site.url }}/assets/2012-11-11-image-0002.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>This diagram is a bit busy, but the interesting part happens in cycle 4. &nbsp;You can see that the pipeline on the top (without prediction) has fetched the branch instruction at address 4, which is incorrect in this case since it should have followed the branch.&nbsp;This has two performance implications:<br /><ol><li>In cycle 5, it squashes the instruction after the mispredicted branch (which is marked with an x). &nbsp;This is a slot that otherwise could have been doing useful work.</li><li>There is a two cycle penalty to restart the strand in cycles 5 and 6. &nbsp;It takes one cycle to fetch an instruction from the instruction cache, and there is another cycle of latency in the instruction FIFO.</li></ol><div>The next chart shows the same program running running four instances in multiple strands without branch prediction. &nbsp;The instructions are numbered as before as before, but hardware strands are represented with different colors.</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-lUdGnlYV1VU/UKMRrQKvPlI/AAAAAAAAAho/m8_QGBgt3MQ/s1600/Screen+Shot+2012-11-13+at+7.35.52+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="44" src="{{ site.url }}/assets/2012-11-11-image-0003.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div>The branch is still mispredicted, but it's not necessary to make a version of this diagram with branch prediction enabled because it won't look any different:<br /><ul><li>When the branch misprediction is detected in cycle 10, there are no other instructions from the same strand in the pipeline to squash.&nbsp;</li><li>The restart penalty is hidden. &nbsp;Other strands still have instructions ready to issue during cycles that the mispredicted strand is reloading its instruction FIFO.</li></ul>In more complex programs there are cases where branch prediction does improve performance. For example, all of the threads may not be runnable, reducing their ability to hide the impact of branch mispredictions. However, multithreading seems to mitigate a substantial portion of the overhead.<br /><br /></div><div>With this in mind, we can use different metrics to evaluate the copy benchmark. &nbsp;This graph shows the number of squashed instructions in each case, which is computed by subtracting the&nbsp;number of instructions&nbsp;that ran to completion from&nbsp;the number of instructions&nbsp;issued:<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Pb90sXGWciE/UPYbl3BATRI/AAAAAAAAAmA/96GlHyXkkqc/s1600/Screen+Shot+2013-01-15+at+7.16.20+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="310" src="{{ site.url }}/assets/2012-11-11-image-0004.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div></div>Both the single and multi-threaded versions take the exact same number of mispredicted branches, but there are many more squashed instructions in the single threaded case.&nbsp;The squashed instructions are symptomatic of the issues discussed earlier. Ultimately, it increases the number of wasted machine cycles.&nbsp;It could be said that branch prediction and hardware multithreading are different ways of achieving the same goal: keeping the arithmetic units as busy as possible with real work.<br /><br />There are more sophisticated schemes for branch prediction--many utilize the history of taken branches for example. However, for this architecture, it arguably doesn't make a lot of sense to make a large investment in improving branch prediction. &nbsp;Even in the case where it can predict the majority of branches correctly, we'd expect the performance improvement to be relatively small because hardware multi-threading hides the cost of mispredicted branches.&nbsp;GPGPU workloads are naturally amenable to being broken into lots of small tasks, so it is easy to keep hardware threads busy. For this application, hardware multithreading is a simple way to improve performance.&nbsp;There are other types of workloads that much more reliant on single threaded performance and thus would benefit much more from branch prediction, which is why many modern processors spend many gates to improve it. &nbsp;It should also be noted that the applications targeted at GPGPUs heavily utilize conditional execution with mask registers rather than branching to take advantage of the vector execution unit. &nbsp;This also reduces the need to optimize branch prediction.<br /><br />The end result was not a surprise to me, but I believe there is still value in confirming one's assumptions. At a minimum, it allows developing a deeper understanding of concepts. It develops the habit of being skeptical and thinking critically. &nbsp;But, the best reason is that there will be an occasional surprise, and those are incredibly valuable for learning new things.<br /><br />