---
layout: post
title: VideoCore QPU Pipeline
date: '2016-03-01T22:01:00.001-08:00'
author: Jeff
tags:
- hardware
- instruction set
- videocore
- gpu
modified_time: '2016-04-21T18:40:06.083-07:00'
thumbnail: https://1.bp.blogspot.com/-47R69gQZy7Q/VtPEGchyBrI/AAAAAAAACMI/AAXd7Dh4CJs/s72-c/vc_pipeline.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-2108068799251005829
blogger_orig_url: http://latchup.blogspot.com/2016/03/videocore-qpu-pipeline.html
---

As a followup to the last post, I've taken a closer look at the Quad Processor Unit that executes shaders on the VideoCore GPU. Although it superficially looks like a CPU, there are some important fundamental differences, and the reasons for them are interesting.<br /><br /><a name='more'></a><br />Here's a simplified version of the QPU's compute pipeline from figure 2 (p. 17) of the <a href="https://www.broadcom.com/docs/support/videocore/VideoCoreIV-AG100-R.pdf" target="_blank">VideoCore Architecture Guide</a>.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-47R69gQZy7Q/VtPEGchyBrI/AAAAAAAACMI/AAXd7Dh4CJs/s1600/vc_pipeline.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="308" src="{{ site.url }}/assets/2016-03-01-image-0000.png" width="400" /></a></div><br />The first notable thing about this diagram is that the main register file is split into two banks: regfile A and regfile B. Instructions encode which bank each operand comes from. There are constraints around how these registers are used: An instruction can only fetch one operand from each bank. For example, the following is fine, because it fetches register 7 from bank A and register 4 from bank B:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; fmul ra1, ra7, rb4&nbsp;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span>But the next one is illegal. It tries to fetch both register 7 and 13 from bank A.<br /><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; fmul ra1, ra7, ra13</span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span></div>This constraint exists because each bank only has one <i>read port</i>. This differs from most CPUs (and <a href="https://github.com/jbush001/NyuziProcessor" target="_blank">Nyuzi</a>), which have one register file with at least two read ports and can use any combination of register operands without restriction.<br /><br />To understand this design decision, it's first useful to talk about how ports are synthesized--specifically on ASICs.<br /><br />The following is a simplified schematic of a single bit inside an SRAM. This is called a 6T cell because it has six transistors. Q1, Q2, Q3, and Q4 form a latch: a pair of cross coupled inverters. A bunch of cells like this are arranged in a 2D grid. &nbsp;A word line signal (WL) connects all cells on the same row, and two bit line signals (BL), which are inverses of each other, connect to all cells on the same column. When a specific word line is activated--only one ever is--all latches on that row are connected to the bit lines via Q5 &amp; Q6. The bit lines are read or written at the bottom or top edge of the array (when writing, the column drivers overpower the latch transistors).<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-jPMoKFd6KUU/VtZpGQ3dtvI/AAAAAAAACOo/yPlSY73Q4G4/s1600/6t_sram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="251" src="{{ site.url }}/assets/2016-03-01-image-0001.png" width="400" /></a></div><br />This port can read or write one value at a time. To perform an independent access in parallel, another port is needed. This requires an extra word line per row, a new pair of bit lines per column, and two additional transistors (Q7 &amp; Q8) per cell to connect them:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-cCfsAN343ac/VxmA4FeOQPI/AAAAAAAACQ8/oHqBInsn9MgcgWEkAL2oZ6Lfz-X_b9k9QCK4B/s1600/two_port.png" imageanchor="1"><img border="0" height="268" src="{{ site.url }}/assets/2016-03-01-image-0002.png" width="400" /></a></div><br /><br />This makes everything physically larger, and the connecting wires longer, which uses more power.<br /><br />I can quantify this using a tool called CACTI (<u>C</u>ache&nbsp;<u>A</u>ccess and&nbsp;<u>C</u>ycle&nbsp;<u>TI</u>me), which builds an electrical model of the wires and transistors in the SRAM array and estimates its area, power usage, and latency. Full source code to the tool is available <a href="https://github.com/hpelabs/cacti" target="_blank">here</a>, but an online version is also available:<br /><br /><a href="http://quid.hpl.hp.com:9081/cacti/sram.y">http://quid.hpl.hp.com:9081/cacti/sram.y</a><br /><br />First, I'll compute the parameters for the QPU as it is described in the documentation. Each entry in the register file has 16 SIMD lanes (times four bytes per entry is 64 bytes per register). There are 64 registers, which is 4096 bytes per QPU. I divide this by two in the computation because there are two register banks (I'll multiply the resulting area by two again).<br /><br />The documentation repeatedly refers to the register memories as 'single ported', but I believe they are referring only to the read ports and these memories must have both a read port and a write port for the result:<br /><br /><ul><li>Otherwise instruction issue would need to stall for every retired instruction that writes back to the register files, which would have pretty crummy performance.</li><li>This would require extra logic to detect collisions. This would be odd, since they don't detect other, simpler types of hazards (for example, on p. 37, the mention that "An instruction must not read from a location in physical regfile A or B that was written to by the previous instruction" because there is no bypassing)</li></ul><br />The QPUs each have four execution pipelines that they issue the same instruction to four times to process all sixteen vector lanes, so the register file needs to read four vector lanes at a time (128 bits).<br /><br />Given these parameters, I can use the CACTI to characterize the register files (Note that the "Nr. of Banks" parameter for CACTI has a different meaning than "banks" as I've been referring to here, so I keep it 1).<br /><br /><a href="http://3.bp.blogspot.com/-_OE5T1PvfUg/VtZ5IzpXbxI/AAAAAAAACPE/RA0Ppv-O4XU/s1600/Screen%2BShot%2B2016-03-01%2Bat%2B9.24.30%2BPM.png" imageanchor="1"><img border="0" height="352" src="{{ site.url }}/assets/2016-03-01-image-0003.png" width="640" /></a><br /><br /><br />The result:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Total read dynamic energy per read port(nJ):&nbsp;0.00454679252507<br />Total standby leakage power per bank (W):&nbsp;0.00109152252016<br />Total area (mm^2):&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">0.0342587754656</span><br /><br />I multiply the area and power by two because there are two banks:<br /><br />Read port power = (0.00454679252507&nbsp;nJ * 250 MHz +&nbsp;0.00109152252016&nbsp;W) * 2 banks = 2.27&nbsp;mW<br />Area =&nbsp;0.193458538913<span style="font-family: inherit;">&nbsp;* 2 =&nbsp;</span>0.0685175509312<span style="font-family: inherit;">&nbsp;mm^2</span><br /><br />Let's now compute values for a CPU-like version with two read ports and one write port. This would allow using all registers as operands without constraints. Since this isn't longer banked, I don't halve the memory size.<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Total read dynamic energy per read port(nJ):&nbsp;0.00791710847258<br />Total standby leakage power per bank (W):&nbsp;0.0028442195272<br />Total area (mm^2):&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">0.0932270438867</span><br /><br />Read power =&nbsp;0.00791710847258&nbsp;nJ * 2 ports * 250 MHz&nbsp;+&nbsp;0.0028442195272&nbsp;W = 3.96 mW<br /><br />The area is 2.7x larger and it uses 1.7x as much power, which seems to justify the VideoCore designers decision to use single ported memory (especially as there are 4 QPUs per slice and at least 3 slices).<br /><br />Each register bank has 32 general purpose registers, for 64 total. That's more than most CPUs, and there is a good reason for it: they can't be spilled. The QPUs don't have load and store instructions, and consequently no stack, so there's nowhere to put them.<br /><br />In the QPU diagram, there are four more general purpose registers in the lower left (r0-r3), which are referred to as accumulators in the documentation. These can be used without restriction as any operand or destination. They are useful as temporaries to work around these register constraints.<br /><br />These temporaries also enable another optimization. There are separate, 3-stage pipelines for addition and multiplication. In most CPUs, each instruction can encode a single operation. However, if VideoCore did that, half of the stages in either pipeline would always be idle. That is something no GPU designer can bear. Instead, the VideoCore QPU uses a 64-bit wide instruction which can encode both operations to execute simultaneously. This is an example of a design principle seen throughout this chip: keep every functional unit as busy as possible. This diagram from figure 3 (p. 27) shows how instructions are encoded:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-oOatgaf1fs8/VtPG69SjwcI/AAAAAAAACMU/ajzCx7kzWac/s1600/Screen%2BShot%2B2016-02-28%2Bat%2B8.19.34%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="94" src="{{ site.url }}/assets/2016-03-01-image-0004.png" width="640" /></a></div><br />The add_a, add_b, mul_a, and mul_b fields control the four multiplexers in the center of the pipeline diagram above. These can select one of the accumulator registers, or a result from one of the banked register files. The raddr_a and raddr_b fields form addresses into the two register files for read, and the waddr_add/waddr_mul control the write port address. This introduces another constraint: the add and multiply instructions cannot write their results to the same bank.<br /><br />For comparison, if the architecture supported two operation instructions without any constraints, it would require a register file with four read ports and two write ports:<br /><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Total read dynamic energy per read port(nJ):&nbsp;0.012013930148<br />Total standby leakage power per bank (W):&nbsp;0.00469288164114<br />Total area (mm^2):&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">0.292972180628</span><br /><div><br />Read port power =&nbsp;0.012013930148 nJ * 4 ports * 250 MHz +&nbsp;0.00469288164114 W&nbsp;&nbsp;= 12.01 mW<br /><br />This is 8 times larger than the actual design and uses 5 times as much power. <br /><br />This instruction encoding impacts code size. In the case where it can pair add and multiply operations in the same instruction, this is no difference in size than having two 32-bit instructions. However, it may not be possible to pair them if and add and multiply don't occur successively in the program, or if there is a bank conflict. Instructions that aren't ALU operations, like load_immediate or &nbsp;branches cannot be paired with other ones and consume an entire 64 bit instruction. So, the code is most likely going to be larger, but, since shaders are fairly simple and there aren't a lot of them, this seems like an appropriate tradeoff (unfortunately, since the shader compiler seems to be hidden inside a binary blob, it's tough to tell how much overhead this introduces).</div><br />In summary, there are some key differences between the QPUs in VideoCore and a general purpose architecture like Nyuzi:<br /><ul><li>VideoCore does not have load/store instructions.</li><ul><li>It needs a larger register file to accommodate all temporaries.&nbsp;</li><li>This eliminates the need for a data cache, making the QPUs smaller</li><li>The QPUs are less flexible (for example, they don't support recursion) and require specialized external hardware to access in-memory data structures.</li></ul><li>VideoCore uses banked register files to save power and area, but this makes the compiler more complex and requires extra instructions to transfer results to/from accumulators.</li><li>VideoCore uses 64-bit wide instructions that can encode multiple operations, at the cost of larger code.</li></ul><div>While the use of load store instructions, and the larger instructions are tradeoffs that would be inappropriate for Nyuzi's use cases, it's interesting to explore if there would be an advantage to using banked registers on Nyuzi.&nbsp;</div><div><br /></div><div>The default configuration for Nyuzi has two read ports and one write port. There are four threads with 32 vector registers, which are 512 bits wide for each. &nbsp;The read and write ports are 512 bits wide. For simplicity, I'll ignore the scalar register file, which is much smaller than the vector one. The RAM size is 64 bytes per reg * 32 regs * 4 threads = 8192 bytes</div><div><br /></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Total read dynamic energy per read port(nJ): 0.0426987452745<br />Total standby leakage power per bank (W): 0.00431499044499<br />Total area (mm^2): 0.680605555836</span></div><div><br /></div><div>At 250Mhz, this results in:</div><div><br /></div><div>0.0426987452745 nJ * 2 ports * 250Mhz +&nbsp;0.00431499044499 W = 21.35 mW</div><div><br /></div><div>This is for a core with four threads. The previous numbers for VideoCore were computed per QPU, of which there are four in a slice (a VideoCore slice and roughly equivalent to a Nyuzi core, both having sixteen execution units and four effective threads of execution). &nbsp;If we multiply the previous numbers, we end up with ~ 9.08 mW of power for a VideoCore slice, about half that of Nyuzi.</div><div><br /></div><div>Now let's examine an alternative version of Nyuzi with two registers banks:</div><div><br /></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">Total read dynamic energy per read port(nJ): 0.0302475000381<br />Total standby leakage power per bank (W): 0.00201081979371<br />Total area (mm^2): 0.298628831583</span></div><div><br /></div><div>The power is now&nbsp;0.0302475000381 nJ * 2 banks * 250 Mhz +&nbsp;0.00201081979371 W =&nbsp;15.12 mW</div><div>The area is&nbsp;0.597257663166 mm^2</div><div><br /></div><div>The non-banked version of Nyuzi is 1.1x times larger and uses 1.7x times as much power as the banked version would.</div><div><br /></div>