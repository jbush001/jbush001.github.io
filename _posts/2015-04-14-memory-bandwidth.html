---
layout: post
title: The Mystery of the Missing Pixels
date: '2015-04-14T10:18:00.001-07:00'
author: Jeff
tags:
- bus
- memory bandwidth
modified_time: '2016-06-30T23:25:39.943-07:00'
thumbnail: https://1.bp.blogspot.com/-DLkK0RHG4No/VvfzIlXFNsI/AAAAAAAACQY/hLOLS71YCwQDX5K1jPvzNjhASvPhPmbKA/s72-c/memory-system.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-3266532777460891425
blogger_orig_url: http://latchup.blogspot.com/2015/04/memory-bandwidth.html
---

One goal when I started my&nbsp;<a href="https://github.com/jbush001/NyuziProcessor" target="_blank">GPGPU</a>&nbsp;project was to be able to display 3D graphics with my FPGA board on a VGA monitor. This required me to add an SDRAM controller, since there is not enough block SRAM on the FPGA to contain an entire VGA framebuffer. I managed to execute code running out of SDRAM on the processor, and display static images on the monitor. But, to my dismay, when I tried to render animations in real time, the monitor displayed garbage. I imagined all kinds of gnarly data corruption bugs that could exist in the SDRAM controller. Stepping through millions of memory transactions to find the problem was enough to make me want to go back to writing software.<br /><a name='more'></a><br />The VGA controller and CPU share memory through an arbiter.<br /><a href="http://1.bp.blogspot.com/-DLkK0RHG4No/VvfzIlXFNsI/AAAAAAAACQY/hLOLS71YCwQDX5K1jPvzNjhASvPhPmbKA/s1600/memory-system.png" imageanchor="1"><img border="0" src="{{ site.url }}/assets/2015-04-14-image-0000.png" /></a><br />The VGA controller connects to a digital to analog converter (DAC) that drives the analog red, blue, and green color signals to the monitor. It needs to fetch 640 * 480 pixels * 4 bytes per pixel * 60 frames per second to refresh the screen, or 70 MB/second. The VGA dot clock is 25 Mhz, so it must drive a new pixel to the display exactly every 40 nanoseconds while in the middle of a scan line (it doesn't need to drive them during horizontal and vertical blanking periods).<br /><br />My first working hypothesis was that the SDRAM controller was not delivering data fast enough to the VGA controller, because, frankly, that was an easier problem to debug.<br /><br /><h3>A Digression on Memory Bandwidth</h3><br />Before talking about the problem and how I solved it, it's useful to talk in more detail about the memory subsystem.<br /><br />Below is a simple program that runs on Nyuzi and attempts to saturate the memory interface. &nbsp;I'm going to start by profiling reads only for simplicity. I'll demonstrate that these results are applicable to writes and copies. This test performs vector wide reads to improve throughput to the L1 cache. The vector width is the same as a cache line, so each read instruction will cause a cache miss. &nbsp;Because the pointer is volatile, the compiler shouldn't optimize away the reads.<br /><br />&nbsp; &nbsp;<span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp;#define LOOP_UNROLL 16</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; </span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; volatile veci16_t *src = (veci16_t*) region1Base;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; veci16_t result;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; int transferCount = kTransferSize /&nbsp;(64 * LOOP_UNROLL);</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; do</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; {</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; result = src[0];</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; result = src[1];</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; ...</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;result = src[15];</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;src += LOOP_UNROLL;</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; }</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; while (--transferCount);</span><br /><div><br />Words like <i>shouldn't</i>&nbsp;always make me a bit nervous, so, just to be sure, I dumped the assembly output. There are 16 unrolled load instructions in a row (a total of 1024 bytes), followed by a few instructions to update the pointer and loop:</div><br /><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">.LBB0_1:&nbsp;</span></div><div class="p1"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; load_v v0, (s0)</span></div><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span"></span>&nbsp; &nbsp; load_v v0, 64(s0)</span></div><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span"></span>&nbsp; &nbsp; load_v v0, 128(s0)</span></div><div class="p1"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; ...</span></div><div class="p1"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; load_v v0, 960(s0)</span></div><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span"></span>&nbsp; &nbsp; add_i s1, s1, -1</span></div><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span"></span>&nbsp; &nbsp; add_i s0, s0, 1024</span></div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><br /><div class="p1"><span class="s1" style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span"></span>&nbsp; &nbsp; btrue s1, .LBB0_1</span></div><br />I ran this in Verilog simulation with a simulated SDRAM chip that mimics the one on my FPGA board. The SDRAM is single data rate (one transfer per cycle) with a 32 bit wide interface, so the maximum speed is four bytes per cycle. Based on the execution of the time of this test, I computed an average of 1.3 bytes per cycle, utilizing about 32% of the bus capacity.<br /><br />This processor uses the <a href="http://www.arm.com/products/system-ip/amba-specifications.php" target="_blank">AMBA AXI</a> protocol to communicate with the memory controller. I won't spend much time diving into that protocol here--there are really only two signals we need to look at for the purposes of our analysis. &nbsp;The m_arvalid (read address valid) signal indicates the host is requesting a new read transfer, and the s_rvalid (read data valid) indicates when the memory controller is responding with data. &nbsp;Here is a waveform of this test running in Verilog simulation:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-OaN79TIeXY4/VS0ksd-otLI/AAAAAAAAB4w/fJUvrDdzGSE/s1600/Screen%2BShot%2B2015-04-14%2Bat%2B7.30.39%2BAM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="104" src="{{ site.url }}/assets/2015-04-14-image-0001.png" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">There are a number of things going on here, but it's useful to look first at the m_arvalid signal. The distance between each processor request is 48 cycles. &nbsp;During that time, it performs 16 transfers (times 32 bits per transfer, the width of the SDRAM interface = 64 bytes, which is the size of a cache line). &nbsp;This matches the results I measured above.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">This test was only using one hardware thread. As we've seen in previous posts, hardware threads can improve utilization and hide memory latency. I modified the test to use four threads, fetching interleaved addresses:</div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-mlT2otoX9m4/VS0i__JIPUI/AAAAAAAAB4k/90tyg5zSuZo/s1600/Screen%2BShot%2B2015-04-14%2Bat%2B7.23.39%2BAM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="108" src="{{ site.url }}/assets/2015-04-14-image-0002.png" width="640" /></a></div><br /><br />This test transfers an average of 2.3 bytes per cycle, utilizing about 57% of the memory bandwidth. &nbsp;It fills a cache miss every 27 cycles. &nbsp;This is much better, trimming off 21 cycles per cache miss. <br /><br />In the single threaded case, the thread is blocked during those 21 cycles. &nbsp;Among other things, this delay includes the restarted L2 fill moving through the L2 cache pipeline, the time for the next instruction to move through the instruction pipeline, another pass through the L2 cache pipeline for the subsequent cache miss, as well as delays for various intermediate queues.<br /><br />This processor delay is completely removed by using four threads. How can I be sure? There is a FIFO in the L2 cache that contains pending read misses. I added a print of the number of entries in this FIFO every clock cycle:<br /><br />&nbsp; <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; always_ff @(posedge clk, posedge reset)</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; begin : update_gen</span><br /><div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; ...</span></div><div><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; $write("%d ", sync_fifo_pending_load.count);</span></div></div><div><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-kaY0vPRdMeE/VS0sQCpUY0I/AAAAAAAAB5k/Zc2el-x0cK0/s1600/Screen%2BShot%2B2015-04-14%2Bat%2B8.02.57%2BAM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2015-04-14-image-0003.png" /></a></div><br /><br />As you can see, this FIFO is never empty. &nbsp;The execution pipeline is no longer a bottleneck and all of the remaining delay is inside the L2 cache.<br /><br /><i>There's something satisfying about using printfs to debug hardware. It just seems kinda wrong.</i><br /><br />There are still 11 remaining cycles that are wasted. &nbsp;What happens to those? Let's zoom in a little more closely. The trace below includes the SDRAM control signals: CS (chip select), RAS (row access strobe), CAS (column access strobe), and WE (write enable). These signal names originated with non-synchronous DRAM, but in SDRAM don't retain much of their original meaning. They encode an arbitrary four bit operation, which is documented&nbsp;<a href="https://en.wikipedia.org/wiki/Synchronous_dynamic_random-access_memory#Commands" target="_blank">here</a>.<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-LjTrXVTgs1U/VvYb5SYujqI/AAAAAAAACPo/bY8nX__IA7gvtS7USb4Dr4WUgg-Ws_F5g/s1600/waveform.png" imageanchor="1"><img border="0" height="228" src="{{ site.url }}/assets/2015-04-14-image-0004.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>The first gap is four cycles between point A &amp; B.<br /><br />The first cycle is the the time to accept the request and advance the SDRAM controller state machine. In this test configuration, the processor is connected directly to the SDRAM controller, so this only takes 1 cycle. &nbsp;In many real world system-on-chips, CPU requests usually travel through an interconnect, and one or more clock domain crossings. A latency of around 20 cycles is not uncommon. The AXI request and response channels are independent to allow a host to send the next request before the data transfer for the first one is completed. This would mitigate this delay, but Nyuzi doesn't support this yet.<br /><br />In the second cycle, the control signals are asserted to SDRAM to perform a read. After the command is issued, it takes two cycles for the first byte of burst data to come out. &nbsp;This interval is referred to as 'CAS latency'. &nbsp;This is assuming a relatively slow clock. &nbsp;For modern DDR3 SDRAM, for example, this can be anywhere from <a href="http://en.wikipedia.org/wiki/CAS_latency#Memory_timing_examples)" target="_blank">8-16 cycles.</a><br /><br />The last cycle of this is delay in the FIFO between the SDRAM output and AXI.<br /><br />The second gap is between C &amp; D. &nbsp;SDRAM transfers data in fixed size bursts of 8 transfers. &nbsp;The processor has requested a burst of 16 transfers (each is four bytes, total of 64 bytes). &nbsp;So, in the middle of the transfer, the SDRAM controller needs to send another read command to set up the next SDRAM burst. &nbsp;The timing of this is similar to the gap between A &amp; B, except the first cycle is related to the state machine transition in this case.<br /><br />The remaining gap of two cycles is between E &amp; F. &nbsp;My L2 AXI fill state machine has a state to indicate read completion, then goes back to the idle state before checking for the next transaction. Restructuring the state machine could shave off these two cycles.<br /><br />Before the controller can read SDRAM, it must 'activate' the row is is going to read from. This is involves connecting one of the rows of capacitors to the array of sense amplifiers. &nbsp;My SDRAM controller lazily leaves rows open after activating them, so most of the time it skips this step, as it did in the trace above. Most modern SDRAM controllers do this, and, just to throw a little more confusing terminology in the mix, the scenario where a row is not already open is referred to as a "DRAM page miss."<br /><br />Below is an example where the controller needs to activate a row. There are three commands in a row starting at marker A (A command is active when dram_cs_n is low):<br /><ul><li>A precharge command to close the existing row</li><li>An activate command to open the new row</li><li>A read command to read the data, as in the previous examples</li></ul><a href="http://3.bp.blogspot.com/-tRoY4hjTn1Y/VvYdyKTGW2I/AAAAAAAACP0/1FxpryD8LcA8PkqEVa8BIF04Yc0U6Tbdw/s1600/row-activate.png" imageanchor="1"><img border="0" height="216" src="{{ site.url }}/assets/2015-04-14-image-0005.png" width="640" /></a><br /><br />One notable thing about this trace is that the commands aren't issued back to back. The datasheet for this part indicates that between the precharge and activate commands, there must be a delay of 21 nanoseconds (this is denoted tRP or Row Precharge Time). The clock here is 50 MHz, which is a period of 20 ns--just a hair short--so I use a delay of two cycles. Likewise, between the activate command and the first read command, a 21 ns delay is required (this is tRCD or RAS to CAS delay). &nbsp;Because the clock rate is low for this configuration, it's only a few cycles, but the number of clocks would increase as the clock rate did.<br /><br />For this test, it's only necessary to open a row when the copy crosses a 32k boundary (this size is based on the physical layout for this specific part). But this is a well behaved access pattern, which has a DRAM page hit rate of 65%. &nbsp;A random access pattern would need to activate rows more often, which would reduce throughput.<br /><div class="separator" style="clear: both; text-align: center;"><br /></div>Here are the test results for <a href="https://github.com/jbush001/NyuziProcessor/tree/master/software/benchmarks/membench">write and copy tests</a>, which are structured similarly to the read test and are using four threads:<br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span><br /><div class="p1"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">copy: 0.99220066 bytes/cycle</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">read: 2.18565583 bytes/cycle</span><br /><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">write: 2.18943238 bytes/cycle</span></div><br />The write test is similar to the read test because it involves similar bus transactions. &nbsp;The copy test reports about half the speed of either because it needs to do two memory transactions per byte. Multiplying the read number by the 50 MHz clock rate gives a best case transfer rate of 115 MB/second. This is about 57% of the "speed of light" of the SDRAM if it were able transfer every cycle with no delays. This is a pretty typical utilization for real world systems in my experience.<br /><br /><h3>The Problem with Fairness</h3><div><br />Given the numbers computed above, I can compute a rough memory bandwidth budget for the problematic use case. &nbsp;If SDRAM has a peak transfer rate of 115 MB/second and the VGA controller needs 70 MB/second, this leaves 45 MB/second for the CPU. But if the CPU and VGA are accessing different rows in the same bank, they will end up causing more DRAM page misses which will reduce this number.</div><div><br /></div><div>I made the arbiter prioritize the VGA controller for reads, knowing bandwidth was tight and that it couldn't tolerate delays (when the VGA is in the middle of a scan line, it must deliver a new pixel to the VGA DAC exactly every 2 cycles or 40 nanoseconds). As it turned out, there were a few problems:</div><div><ul><li>The AXI protocol treats read and write channels independently, as did my arbiter. The SDRAM controller can only handle one at a time, so it pingponged between writes and reads.&nbsp;</li><li>The the burst length for the VGA controller was half that of the CPU, so, when it did ping pong, the CPU would get 2/3 of the bandwidth, and the VGA would only get 1/3.</li></ul></div><div>To make sure things were properly stacked unfairly in favor of the VGA, I prioritized reads in the SDRAM controller and increased the VGA burst size to twice of that of the CPU. This <a href="https://github.com/jbush001/NyuziProcessor/commit/6687d98d006683cde18355be445ed0f2957e1c02" target="_blank">change</a>&nbsp;addressed what I confirmed was a VGA underrun issue, but introduced a <a href="https://github.com/jbush001/NyuziProcessor/commit/a5c0dccbe2d344772073bb3ed0b1153d66fde918" target="_blank">horrible, subtle race condition</a> that would cause some programs to hang after running for around 30 seconds on FPGA (1.5 billion cycles). This took me far longer to debug than the original problem.</div><div><br /></div>