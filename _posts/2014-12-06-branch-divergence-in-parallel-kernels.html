---
layout: post
title: Branch Divergence
date: '2014-12-06T23:06:00.000-08:00'
author: Jeff
tags:
- amd
- branch divergence
- southern islands
- llvm
modified_time: '2016-11-05T06:46:13.485-07:00'
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-3477634446071970093
blogger_orig_url: http://latchup.blogspot.com/2014/12/branch-divergence-in-parallel-kernels.html
---

Modern GPUs utilize <a href="http://en.wikipedia.org/wiki/SIMD" target="_blank">SIMD</a> heavily (under various monikers: SPMD, SIMT, etc). &nbsp;Whatever the name, it fundamentally boils down to duplicating arithmetic units and applying the same instruction to many vector lanes, each of which represents an independent instance of the program. Because the non-arithmetic parts of the pipeline are shared, this allows packing more computation in a smaller amount of space. <br /><br />This works well until conditional execution is thrown into the mix. &nbsp;It's possible (common, actually) that some of the instances will chose one branch and some will chose another. &nbsp;This is called "branch divergence," and is an active area of research.  I've recently written a <a href="https://github.com/jbush001/NyuziToolchain/tree/master/tools/spmd-compile" target="_blank">compiler</a> for a simple, C-like language that can produce parallel kernels for the instruction set of the <a href="https://github.com/jbush001/NyuziProcessor" target="_blank">processor</a> I've been working on. It uses the LLVM backend I've already developed for this architecture. It's interesting to compare the generated code to a modern GPU, AMD's "Southern Islands"&nbsp;architecture.<br /><br /><a name='more'></a><br />The <a href="http://developer.amd.com/wordpress/media/2012/12/AMD_Southern_Islands_Instruction_Set_Architecture.pdf" target="_blank">reference guide</a>&nbsp;for AMD's Southern Islands architecture, gives an example of a kernel that can exhibit divergent execution in section 2.4:<br /><br /><pre>float fn0(float a, float b)<br />{<br />    if (a &gt; b)<br />        return a * a - b;<br />    else<br />        return b * b - a;<br />}<br /></pre><br />They also include the generated assembly code for this. It's fairly understandable if you know a few basic things: <br /><ul><li>Comparisons set a vector condition code register (which stores a separate result for each lane). This is exposed through a register called 'vcc', which can be used like any other general purpose register.</li><li>There is a special register called 'exec' that controls which vector lanes a result will be written back to. It tracks which threads are active on the current code path.</li></ul><pre><span style="font-family: &quot;times&quot;; white-space: normal;">Here is their code:</span></pre><pre><span style="font-family: &quot;times&quot;; white-space: normal;"><br /></span></pre><pre>     v_cmp_gt_f32 r0, r1        // a&gt;b<br />     s_mov_b64 s0, exec         // Save current exec mask<br />     s_and_b64 exec, vcc, exec  // Do “if”<br />     s_cbranch_vccz label0      // Branch if all lanes fail<br />     v_mul_f32 r2, r0, r0       // result = a * a<br />     v_sub_f32 r2, r2, r1       // result = result - b<br />label0:<br />     s_not_b64 exec, exec       // Do “else”<br />     s_and_b64 exec, s0, exec   // Do “else”<br />     s_cbranch_execz label1     // Branch if all lanes fail<br />     v_mul_f32 r2, r1, r1       // result = b * b<br />     v_sub_f32 r2, r2, r0       // result = result - a<br />label1:<br />     s_mov_b64 exec, s0         // Restore exec mask<br /></pre><br />On the third line, the result of the comparison in vcc is moved into exec.  From this point on, for lanes that the condition was not true for, there will be no effect.  Results will be computed, but the registers will not be updated. After label0, the current mask is inverted, then combined with the previous mask (this would properly handle the case of nested masks).<br /><br /><i>As an aside, previous versions of AMD's architecture handled masks automatically with a hardware stack.  For example, the R700 had PUSH, PUSH_ELSE, and POP instructions. In the newer architectures, they apparently have moved more of this management to the compiler, which must allocate registers to hold intermediate masks when dealing with nested conditionals.&nbsp;</i><br /><br />I'm going to back up a bit and talk about how the equivalent code is generated for my architecture from the same kernel source code given above. The compiler I've written starts out by creating an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">abstract syntax tree</a> for the parsed source. It then walks the tree recursively, calling the generate() method on each node, which then call into a class called SPMDBuilder to create LLVM intermediate code as side effect. <br /><pre>class IfAst : public AstNode {<br />public:<br />...<br />    virtual llvm::Value *generate(SPMDBuilder&amp;);<br /> <br />private:<br /> AstNode *Cond;<br /> AstNode *Then;<br /> AstNode *Else; <br />};<br /><br />Value *IfAst::generate(SPMDBuilder &amp;Builder)<br />{<br /> Builder.pushMask(Cond-&gt;generate(Builder));<br /> Then-&gt;generate(Builder);<br /> if (Else) {<br />  Builder.invertLastPushedMask();<br />  Else-&gt;generate(Builder);<br /> }<br /><br /> Builder.popMask(); <br /> return nullptr;<br />}</pre>SPMDBuilder (which stands for Single Program Multiple Data, the programming model we are using) is a wrapper I've added around the LLVM's standard <a href="http://llvm.org/docs/doxygen/html/classllvm_1_1IRBuilder.html" target="_blank">IRBuilder</a> class, which constructs the <a href="http://llvm.org/docs/LangRef.html" target="_blank">intermediate representation</a>.  SPMDBuilder adds a few special new behaviors. The first is pushMask(), which takes the result from a vector comparison (the Cond variable in this case) and causes it to be applied to subsequent operations.  Masks are stored in an internal stack within the SPMDBuilder, and are pushed and popped as each nested conditional clause is generated.  Note also invertLastPushedMask in the else clause.<br /><br /><i>(for simplicity, I'm not generating short circuit jumps here if all of the conditions go the same way like the AMD code above.  It's not hard to do. There is already a function in SPMDBuilder called shortCircuitZeroMask to handle this.  From a performance perspective, it is debatable.  It some cases it is faster to simply execute the instructions than take the hit of pipeline flush that a branch would produce. Of course, I should measure that :).&nbsp;</i><br /><br />Unlike AMD SI architecture, there isn't an global exec register in this architecture.  Each instruction can optionally take a mask register as a parameter. SPMDBuilder takes care of applying this mask automatically. It only need be applied when a value is written back to a local variable.&nbsp; The meat of that is here, in assignLocalVariable:  <br /><pre>void SPMDBuilder::assignLocalVariable(Value *Variable, Value *NewValue)<br />{<br />  if (MaskStack.empty()) {<br />    Builder.CreateStore(NewValue, Variable);<br />  } else {<br />    // Need to predicate this instruction<br />    llvm::Function *BlendFunc = llvm::Intrinsic::getDeclaration(MainModule, <br />                           (llvm::Intrinsic::ID) Intrinsic::nyuzi_vector_mixf,<br />                           None);<br /><br />    Value *OldValue = Builder.CreateLoad(Variable);<br /><br />    SmallVector<value 3=""> Ops;<br />    Ops.push_back(getCurrentMask());<br />    Ops.push_back(NewValue);<br />    Ops.push_back(OldValue);<br /><br />    Value *Blended = Builder.CreateCall(BlendFunc, Ops, "");<br />    Builder.CreateStore(Blended, Variable);<br />  }<br />}</value></pre>This is a little hard to follow, but the important part is the call to nyuzi_vector_mixf.  Although this looks like a function call, it is actually an <i style="font-family: Arial, Helvetica, sans-serif;">intrinsic </i>that is specific to this architecture. Intrinsic functions are a way of extending LLVM without needing to add new LLVM instructions to the intermediate representation.  They look like function calls on the front end, but they have special properties that can be used during instruction selection.  Here is the LLVM intermediate code generated by above: <br /><pre>%2 = call i32 @llvm.nyuzi.__builtin_nyuzi_mask_cmpf_gt(&lt;16 x float&gt; %0,<br />     &lt;16 x float&gt; %1)<br />...<br />%5 = fmul &lt;16 x float&gt; %3, %4<br />%7 = fsub &lt;16 x float&gt; %5, %6<br />%8 = load &lt;16 x float&gt;* %result<br />%9 = call &lt;16 x float&gt; @llvm.nyuzi.__builtin_nyuzi_vector_mixf(i32 %2,<br />     &lt;16 x float&gt; %7, &lt;16 x float&gt; %8)</pre><div><div>The 16 bit mask, which is the result of the comparison, is the first parameter to the mixf intrinsic. The second is the newly computed value from fsub, and the third is the old value in the variable. &nbsp;For each bit in the mask, it selects the lane from the first parameter if the bit is 1, and the second if it is zero (which is just the value it had before). &nbsp;The fact that it takes the old value as a parameter may seem a bit strange, but bear in mind that LLVM intermediate code is Static Single Assignment form (SSA), so we can never assign the same variable twice. <br /><br /><i>As an aside, you may have noticed that the code above generates stores and loads for every local variable access. &nbsp;The <a href="http://llvm.org/docs/Passes.html#mem2reg-promote-memory-to-register" target="_blank">mem2reg pass</a> in LLVM will convert these to use registers as appropriate. This is the officially recommended way to do this: it saves having to generate&nbsp;<a href="http://llvm.org/docs/LangRef.html#phi-instruction" target="_blank">phi nodes</a>&nbsp;in the front end and is simpler.</i><br /><br />__builtin_nyuzi_vector_mixf&nbsp; doesn't correspond to an instruction in this architecture and has no meaning to the LLVM infrastructure.  It gets passed through all the way through various transformation passes until instruction selection. Here is where the magic happens.&nbsp; This is NyuziInstrInfo.td, the instruction generation template for this architecture, which is used by&nbsp;<a href="http://llvm.org/docs/TableGen/index.html" style="font-family: Times, 'Times New Roman', serif;" target="_blank">TableGen</a>.</div></div><br /><pre>let Constraints = "$dest = $oldvalue" in {<br />    // Vector = Vector op Vector, masked<br />    def VVVM : FormatRMaskedTwoOpInst&lt;<br />        (outs VR512:$dest),<br />        (ins GPR32:$mask, VR512:$src1, VR512:$src2, VR512:$oldvalue),<br />        operator # "_mask $dest, $mask, $src1, $src2",<br />        [(set v16i32:$dest, (int_nyuzi_vector_mixi i32:$mask,<br />             (OpNode v16i32:$src1, v16i32:$src2), v16i32:$oldvalue))],<br />        opcode,<br />        FmtR_VVVM&gt;;<br />}<br /></pre><div>The seventh line (with int_nyuzi_vector_mixi) is the pattern that is matched during instruction selection. The intermediate instruction representation of LLVM is stored as a directed acyclic graph. This pattern represents a fragment of a DAG structure that this instruction will be emitted for. &nbsp;This allows the compiler to combine several LLVM IR instructions into a single target instruction, sub_f_mask, which you can see in the resulting Nyuzi assembly code generated by the compiler:</div><br /><br /><pre> cmpgt_f s1, v0, v1          // a&gt;b<br /> and s2, s1, s0              // and result with previous mask<br /> mul_f v2, v0, v0            // a*a<br /> sub_f_mask v2, s2, v2, v1   // result = a*a-b (for active kernels)<br /> xor s1, s1, -1              // invert the comparison mask<br /> and s1, s1, s0              // recombine with previous mask<br /> mul_f v1, v1, v1            // b*b<br /> sub_f_mask v2, s1, v1, v0   // result = b*b-a (for active kernels)<br /></pre><br />In this code, s0 is the old mask before this conditional code is executed, and s1 is the mask after the condition has been applied. &nbsp;The subtract instructions apply the mask, but the multiplications (which are only intermediate results, stored in temporary registers) don't bother to. &nbsp;In the middle of this code, the xor instruction inverts the mask, which is then anded with the previous mask in the mask stack.<br /><br /><br />