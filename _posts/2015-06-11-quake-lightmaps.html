---
layout: post
title: Quake Lightmaps
date: '2015-06-11T09:30:00.002-07:00'
author: Jeff
tags:
- 3d rendering
- lighting
modified_time: '2016-02-03T22:37:05.970-08:00'
thumbnail: https://2.bp.blogspot.com/-FWF21HtEsa4/VXiqaXZI-KI/AAAAAAAAB-c/AFvENpfTUeg/s72-c/texture-only.png
blogger_id: tag:blogger.com,1999:blog-5853447763770338628.post-4360517119255370373
blogger_orig_url: http://latchup.blogspot.com/2015/06/quake-lightmaps.html
---

I added support for lightmaps to the Quake renderer I discussed in the&nbsp;<a href="{{ site.baseurl }}{% post_url 2015-06-05-not-so-fast %}" target="_blank">last post</a>. &nbsp;<a href="http://www.jagregory.com/abrash-black-book/#chapter-68-quakes-lighting-model" target="_blank">Lightmaps</a>&nbsp;were a big innovation when they first appeared in Quake. By precalculating light and shadow, they allowed much more realistic scenes than would have been possible to compute in realtime. Lightmaps are still&nbsp;<a href="http://docs.unity3d.com/460/Documentation/Manual/LightmappingInDepth.html" target="_blank">used</a>&nbsp;in many games.<br /><a name='more'></a><br />The tricky part of implementing this was that the Quake BSP format doesn't store redundant information. Although it contains the file offsets for the lightmaps, it doesn't have the dimensions of each one. The renderer must compute these by walking the vertices of each polygon face, converting the coordinates to texture space, and finding the bounding rectangle. As with the texture data, I packed these into a single&nbsp;<a href="http://en.wikipedia.org/wiki/Texture_atlas" target="_blank">atlas texture</a>&nbsp;and stored the coordinates as vertex attributes.<br /><br />Here's a rendered frame with only texture mapping, no lighting:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-FWF21HtEsa4/VXiqaXZI-KI/AAAAAAAAB-c/AFvENpfTUeg/s1600/texture-only.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="480" src="{{ site.url }}/assets/2015-06-11-image-0000.png" width="640" /></a></div><div style="text-align: center;"><br /></div>There is a relatively small amount of texture data for each level. Levels reuse textures all over the place, repeating them across each surface. You can see this with the floor tiles in the image above, for example. However, lightmaps can't be reused like this. Every polygon in the level needs a dedicated lightmap. To reduce the amount of data required, lightmaps are stored at low resolution: one sample every 16 pixels in texture space. Also, each sample is 8-bits. The next image shows just the lightmaps rendered for the scene above.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-PKeSrNSoOt8/VXiqMXnAtwI/AAAAAAAAB-M/smAvWOQDksE/s1600/lightmap-nearest.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="478" src="{{ site.url }}/assets/2015-06-11-image-0001.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>It's harder to verify lightmaps are working correctly than it was with textures, because it's not as obvious when it is wrong. This looks mostly correct. There is a shadow on the steps on the left side, and shadows cast by the ductwork above. I can see lighter areas around the lights. There is this odd light strip above the opening on the right side. &nbsp;I think I have an off-by-one in the lightmap atlas setup. Also, the opening on the right side doesn't seem to show the light shining on the lower surface. There is a flickering light there in the game, which the Quake engine renders differently. I haven't implemented that, which I suspect is why the default lightmap value doesn't look right.<br /><br /><div class="separator" style="clear: both;">Here are the same lightmaps with bilinear filtering enabled on the texture sampler, which removes the sharp edges.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/--SkRaYr5P9U/VXiqTx28Y0I/AAAAAAAAB-U/k72uO-OQj44/s1600/lightmap-bilinear.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2015-06-11-image-0002.png" /></a></div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">Now that I have the lightmap data available, I need to multiply it by each pixel in the texture. When id added hardware acceleration to Quake, desktop GPUs didn't support programmable shaders, so they needed some machinations to support lighting. Since my rendering engine does support shaders, the implementation is simpler. The pixel shader is below, with new code&nbsp;<b>bolded. &nbsp;</b>As described in previous posts, this works on 16 pixels at a time.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">void shadePixels(vecf16_t outColor[4],&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; const vecf16_t inParams[16],&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; const void *_castToUniforms,&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; const Texture * const sampler[kMaxActiveTextures],</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; unsigned short mask) const override</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">{</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; vecf16_t atlasU = wrappedAtlasCoord(</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamTextureU&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">- 4],&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamAtlasLeft - 4],&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamAtlasWidth - 4]);&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; vecf16_t atlasV = wrappedAtlasCoord(</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamTextureV&nbsp;</span><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">- 4],&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamAtlasTop - 4],</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><span class="Apple-tab-span" style="white-space: pre;">        </span>inParams[kParamAtlasHeight - 4]);&nbsp;</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp; sampler[0]-&gt;readPixels(atlasU, atlasV, mask, outColor);</span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><br /></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">&nbsp; &nbsp;&nbsp;<b>vecf16_t lightmapValue[4];</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; sampler[1]-&gt;readPixels(</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamLightmapU - 4],&nbsp;</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; &nbsp; &nbsp; inParams[kParamLightmapV - 4],&nbsp;</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; &nbsp; &nbsp; mask,</b></span><b style="font-family: 'Courier New', Courier, monospace;"><span class="Apple-tab-span" style="white-space: pre;">&nbsp;</span></b></div><div class="separator" style="clear: both;"><b style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp; lightmapValue);</b></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b><br /></b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; vecf16_t intensity = lightmapValue[0] + splatf(0.4);</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; outColor[kColorR</b></span><b style="font-family: 'Courier New', Courier, monospace;">] *= intensity;</b></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; outColor[kColorG] *= intensity;</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;"><b>&nbsp; &nbsp; outColor[kColorB] *= intensity;</b></span></div><div class="separator" style="clear: both;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">}</span></div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">In the code above, I've added two new interpolated parameters: the lightmap U and V coordinates. &nbsp;I don't need to worry about repeating lightmaps as I do for the textures. My texture sampler only supports 32-bit textures now, so I use the lowest channel for the intensity and ignore the others. &nbsp;I add a constant ambient value to the lightmap sample--it was too dark otherwise--and multiply that intensity by the texel color.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both;">Here is the original scene with the lightmap applied: The effect is subtle, but looks much more realistic.</div><div class="separator" style="clear: both;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-ADha1WimbHA/VXjHqplcWnI/AAAAAAAAB_A/khSxAeSFr0E/s1600/Screen%2BShot%2B2015-06-10%2Bat%2B4.26.05%2BPM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="{{ site.url }}/assets/2015-06-11-image-0003.png" /></a></div><div class="separator" style="clear: both; text-align: center;"><i>The four white dots&nbsp;</i><i>on the right&nbsp;</i><i>are a gap where the triangles don't fit together tightly. This is probably an issue in my rasterizer.</i></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both;">It also requires more instructions: about 30 million to render the first frame compared to 22 million without lightmaps. &nbsp;Two of the biggest contributors to the profile in the previous post were parameter interpolation and texture sampling, both of which lightmaps require. I could improve this by enabling an 8-bit texture format for the lightmap, which would remove the redundant computations for the unused color channels.</div><div><br /></div>